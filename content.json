{"meta":{"title":"SDLTF","subtitle":"Are you going to Scarborough Fair?","description":"平平无奇的Blog","author":"SDLTF","url":"http://SDLTF.github.io","root":"/"},"pages":[{"title":"","date":"2022-06-24T04:58:40.870Z","updated":"2022-06-24T04:58:40.870Z","comments":true,"path":"404.html","permalink":"http://sdltf.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-06-24T04:57:53.187Z","updated":"2022-06-24T04:57:53.187Z","comments":true,"path":"archives/index.html","permalink":"http://sdltf.github.io/archives/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-06-24T04:58:22.636Z","updated":"2022-06-24T04:58:22.636Z","comments":true,"path":"friends/index.html","permalink":"http://sdltf.github.io/friends/index.html","excerpt":"","text":"暂无w"},{"title":"所有标签","date":"2022-06-24T04:58:05.850Z","updated":"2022-06-24T04:58:05.850Z","comments":true,"path":"tag/index.html","permalink":"http://sdltf.github.io/tag/index.html","excerpt":"","text":""},{"title":"category","date":"2022-06-24T04:56:30.000Z","updated":"2022-06-24T04:56:30.392Z","comments":true,"path":"category/index.html","permalink":"http://sdltf.github.io/category/index.html","excerpt":"","text":""}],"posts":[{"title":"你知道EasyX吗？","slug":"easyx","date":"2022-06-24T04:23:08.183Z","updated":"2021-07-08T07:02:30.198Z","comments":true,"path":"2022/06/24/easyx/","link":"","permalink":"http://sdltf.github.io/2022/06/24/easyx/","excerpt":"关于C++控制台上的图形界面，你知道一个东西叫做EasyX吗？","text":"关于C++控制台上的图形界面，你知道一个东西叫做EasyX吗？ 作为一个退役的OI选手（WTF?$3^2-3^1$年级退役？），在退役之后总想找点事情做。 开发个游戏？（我只会控制台） 学下人工智能？（脑子不够用） 学一下Py？（爱我C++） 好吧，我选择了开发个游戏。但是每次看到自己的游戏都是控制台界面的，很不爽图形界面咋样？ QT？（不会） MFC？（算了吧） EasyX？（这是个什么东西？） 马上我们就要介绍我们今天的主角——EasyX图形库！ 关于EasyXEasyX 是针对 C++ 的图形库，可以帮助 C++语言初学者快速上手图形和游戏编程。安装简单（极其简单），使用简单（这个必须赞），唯一一点不好的，就是只能支持VS系列产品（VC6.0，VSxxx，不包括VSCode） 如何下载？1.打开EasyX官网点我应该是这样子的： 2.点击“下载 EasyX”（在图片的右边，找不到算你眼瞎） 3.直接打开安装包 4.下一步，来到选择界面 5.点击安装（EasyX文档也可以安装一下，但下面的必须点一个） 6.点击关闭 结束 如果你想测试一下，你的EasyX有没有成功安装打开你的VC&#x2F;VS2008&#x2F;VS2010……新建一个“空项目”或者“控制台项目”（记住啦！！重点！！一定是控制台！！）输入： 123456789#include &lt;graphics.h&gt; // 引用图形库头文件#include &lt;conio.h&gt;int main()&#123; initgraph(640, 480); // 创建绘图窗口，大小为 640x480 像素 circle(200, 200, 100); // 画圆，圆心(200, 200)，半径 100 _getch(); // 按任意键继续 closegraph(); // 关闭绘图窗口&#125; f5一下，黑窗口上是不是出现了一个圆？恭喜你，安装成功！ 如何食用？EasyX主要靠函数来进行图形化编程。如果你不知道用啥函数，可以根据帮助文档EasyX_Help.chm来得到相应帮助 在这里举一个例子，电视雪花 12345678910111213141516#include &lt;graphics.h&gt; // 引用图形库头文件#include &lt;conio.h&gt;#include &lt;time.h&gt;#include &lt;cstdlib&gt;int main()&#123; srand((unsigned)time(NULL)); initgraph(640, 480); // 创建绘图窗口，大小为 640x480 像素 while(1)&#123; for(int i = 0;i &lt;= 640;i ++)&#123; for(int j = 0;j &lt; 480;j ++)&#123; putpixel(i,j,rand()%2==1?BLACK:WHITE); &#125; &#125; &#125; &#125; 来个彩色版本的？ 1234567891011121314151617#include &lt;graphics.h&gt; // 引用图形库头文件#include &lt;conio.h&gt;#include &lt;time.h&gt;#include &lt;cstdlib&gt;int main()&#123; srand((unsigned)time(NULL)); initgraph(640, 480); // 创建绘图窗口，大小为 640x480 像素 while (1) &#123; for (int i = 0; i &lt;= 640; i++) &#123; for (int j = 0; j &lt; 480; j++) &#123; int color = rand() % 0x233233; putpixel(i, j, color); &#125; &#125; &#125;&#125; 模拟钟表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;graphics.h&gt;#include &lt;conio.h&gt;#include &lt;math.h&gt; #define PI 3.1415926536 void DrawHand(int hour, int minute, int second)&#123; double a_hour, a_min, a_sec; // 时、分、秒针的弧度值 int x_hour, y_hour, x_min, y_min, x_sec, y_sec; // 时、分、秒针的末端位置 // 计算时、分、秒针的弧度值 a_sec = second * 2 * PI / 60; a_min = minute * 2 * PI / 60 + a_sec / 60; a_hour= hour * 2 * PI / 12 + a_min / 12; // 计算时、分、秒针的末端位置 x_sec = int(120 * sin(a_sec)); y_sec = int(120 * cos(a_sec)); x_min = int(100 * sin(a_min)); y_min = int(100 * cos(a_min)); x_hour= int(70 * sin(a_hour)); y_hour= int(70 * cos(a_hour)); // 画时针 setlinestyle(PS_SOLID, 10); setcolor(WHITE); line(320 + x_hour, 240 - y_hour, 320 - x_hour / 7, 240 + y_hour / 7); // 画分针 setlinestyle(PS_SOLID, 6); setcolor(LIGHTGRAY); line(320 + x_min, 240 - y_min, 320 - x_min / 5, 240 + y_min / 5); // 画秒针 setlinestyle(PS_SOLID, 2); setcolor(RED); line(320 + x_sec, 240 - y_sec, 320 - x_sec / 3, 240 + y_sec / 3);&#125; void DrawDial()&#123; // 绘制一个简单的表盘 circle(320, 240, 2); circle(320, 240, 60); circle(320, 240, 160); outtextxy(296, 310, &quot;BestAns&quot;); // 绘制刻度 int x, y; for (int i=0; i&lt;60; i++) &#123; x = 320 + int(145 * sin(PI * 2 * i / 60)); y = 240 + int(145 * cos(PI * 2 * i / 60)); if (i % 15 == 0) bar(x - 5, y - 5, x + 5, y + 5); else if (i % 5 == 0) circle(x, y, 3); else putpixel(x, y, WHITE); &#125;&#125; void main()&#123; initgraph(640, 480); // 初始化 640 x 480 的绘图窗口 DrawDial(); // 绘制表盘 setwritemode(R2_XORPEN); // 设置 XOR 绘图模式 // 绘制表针 SYSTEMTIME ti; // 定义变量保存当前时间 while(!kbhit()) // 按任意键退出钟表程序 &#123; GetLocalTime(&amp;ti); // 获取当前时间 DrawHand(ti.wHour, ti.wMinute, ti.wSecond); // 画表针 Sleep(1000); // 延时 1 秒 DrawHand(ti.wHour, ti.wMinute, ti.wSecond); // 擦表针（擦表针和画表针的过程是一样的） &#125; closegraph(); // 关闭绘图窗口&#125; 啥？你要鼠标操作？ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;graphics.h&gt;#include &lt;conio.h&gt; int main()&#123; // 初始化图形窗口 initgraph(640, 480); MOUSEMSG m; // 定义鼠标消息 while(true) &#123; // 获取一条鼠标消息 m = GetMouseMsg(); switch(m.uMsg) &#123; case WM_MOUSEMOVE: // 鼠标移动的时候画红色的小点 putpixel(m.x, m.y, RED); break; case WM_LBUTTONDOWN: // 如果点左键的同时按下了 Ctrl 键 if (m.mkCtrl) // 画一个大方块 rectangle(m.x-10, m.y-10, m.x+10, m.y+10); else // 画一个小方块 rectangle(m.x-5, m.y-5, m.x+5, m.y+5); break; case WM_RBUTTONUP: return 0; // 按鼠标右键退出程序 &#125; &#125; // 关闭图形窗口 closegraph(); return 0&#125; 在帮助文档里，也有很多实例哦~相信各位大佬能做出更好的东西！ 完结 感谢观看","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://sdltf.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"http://sdltf.github.io/tags/C/"}]},{"title":"2021年5月27日在Reddit的回答","slug":"reddit20210527","date":"2021-05-27T05:05:55.000Z","updated":"2021-05-30T06:04:58.670Z","comments":true,"path":"2021/05/27/reddit20210527/","link":"","permalink":"http://sdltf.github.io/2021/05/27/reddit20210527/","excerpt":"","text":"How to tutor young kids (grade 1) mathQuestion: Currently I’m mainly working through worksheets with them, but I was wondering if I should also be teaching them? Or what advice does everyone have? Not gonna lie, I’m struggling a bit to keep them engaged. 原文链接 看起来是一个数学老师的困惑呢！ Answer: 你好，我是一个中国学生。Hello, I’m a student in China. 我特地去找了找我们的一年级数学书（人教版）上都讲了什么内容： 如何数数 比较大小 10以内数字的分解 10以内的加减法 I went to find our first grade math book (PEP）: How to count Compare Decomposition of numbers within 10 Addition and subtraction within 10 我觉得大部分一年级的小孩子都会比较喜欢通过游戏、唱歌的方式来学习数学，并且他们需要从生活中认识数学。也许Youtube上的一些教学视频会有用。我的数学老师是国家级的，我记得我们刚刚上“数数”这节课的时候，她让我们每个人都提供一种数数的方法。这样，每个人都能参与到课堂中来。 I think most of the children in Grade one prefer to learn mathematics through games and singing, and they need to learn mathematics from life. Maybe some instructional videos on YouTube will be useful. My math teacher is one of the best teachers in China. I remember when we just had the “counting” class, she asked each of us to provide a way to count. In this way, everyone can participate in the classroom. 特别的，我想和你分享几个关于我们数学老师的教学方法： “我来说”。这个模式下，每个人都可以站起来抢答问题。大家可以随意的在一起讨论各种问题。 “开火车”。当然，这几乎每个中国的数学老师都有这么一个方法。让某一列的学生依次回答问题。 “数学日记”。他代替了数学笔记。我们老师要求我们如果那天上了数学课，把你所学到的内容、你的感悟都写到你的日记中去。 In particular, I’d like to share with you some teaching methods of our math teachers “I can answer!” In this mode, everyone can stand up and answer questions. We can discuss all kinds of problems - together at will. “Drive the train.”(I don’t know how to turn “开火车” into English). Of course, almost every Chinese math teacher has such a method. Ask the students in one column to answer the questions in turn. “Mathematics diary”. It took the math notes instead. Our teacher asked us to write down what you have learned and what you have learned in your diary if we had a math class that day. 希望对你有用。Hope can help you","categories":[],"tags":[{"name":"reddit","slug":"reddit","permalink":"http://sdltf.github.io/tags/reddit/"}]},{"title":"2021年5月26日在Reddit的回答","slug":"reddit20210526","date":"2021-05-26T05:05:55.000Z","updated":"2021-05-30T06:07:55.747Z","comments":true,"path":"2021/05/26/reddit20210526/","link":"","permalink":"http://sdltf.github.io/2021/05/26/reddit20210526/","excerpt":"","text":"Advice for teaching math to friends?Question： My high school has a knack for making math seem more complicated than it actually is (almost as if Lockhart’s Lament incarnated). I’ve learned that almost all of my classmates are having difficulty learning Trigonometry this year and even Algebra the past years. So, I often find myself teaching concepts to my friends since I’m apparently the mathematician&#x2F;physicist of the group. However, while I still find the topics simple and feel that I understand it well enough to teach, I sometimes find my students still confused, even if it was just visualizing concepts. I’ve always believed in Einstein’s quote saying “if you can’t explain it simply, you don’t understand it well enough,” but maybe I need something more. I want to spread the beauty of math just as everyone here has been doing! I’ll take any advice you have. I’ve found that sometimes I end up cluttering my ideas, and I throw more words than I feel I should, so tips for organizing ideas would be helpful too! 原文链接 这大概就是数学学霸的忧伤吧…… Answer: 我不知道题主所谓的“三角学”包括哪些部分，在中国，初中的三角学包括： 三角形 全等三角形 相似三角形 三角函数 勾股定理 圆和三角形、四边形和三角形 等等 I don’t know what the “Trigonometry” you mean. In China, trigonometry in junior middle school includes: Triangle Congruent triangle Similar triangle Trigonometric function Pythagorean theorem Circle and triangle, quadrilateral and triangle and so on. 确实，很多人都不能很好的理解有关三角形的知识，我一开始在学习的时候也感到吃力——尤其是三角函数。我的方法是： 把所有的概念画到图形上 多自己亲手画图 自己推导所有的公式、定理 It’s true that many students do not understand something about triangles well, and I am also struggling at the outset of learning - especially with trigonometric function .My approach is: Draw all concepts onto the figure Multiple oneself handedness sketchdrawing Derive all the formulas, theorem yourself 希望能帮到你！ Hope can help you! The pandemic is beating the last bits of my love of math out from me, and I don’t know what to do.​Question： It’s 12pm. I’m writing out the answers to some stupid exam with easy questions that no longer interest me. It’s been months since I last managed to read more than 5 pages from a maths book, or hell enjoy much things at all. (The only thing that sometimes keeps me entertained is bullet chess). After years and years of being passionate about maths, and everything about it, from the education system teaching me that my love for not calculating things out is wrong, to being rejected by every higher-educational institution I actually wanted to go (both for BSc and Masters), it seems this is the final straw. The thrill I used to get after that last nice step in the proof is gone for me, and I don’t know what to do. My whole life was meant to be based around mathematics, but it feels like every time I take a step in that direction, the mathematical world pushes back against me. I used to get very involved in projects. It seems every time I do, I am a burden to professors there, not someone they enjoy talking to about random interesting intricacies, the way I was. Meanwhile, all sorts of further study programs don’t seem to care about my clear passion, my grades, or anything, just choosing me to reject me with the standard “we are too busy to even bother giving feedback” (and oh, I have tried). I’m not burnt out; I barely spend time doing maths as is anymore, I go on walks (which is my favourite escape) and socializing with friends fairly often. But I just feel so hopeless. For some reason, this stupid virus has really just absolutely destroyed everything of my mathematical mental state, with things such as “columns of matrices are vectors” no longer being the instant sharp thought they were, but instead coming beleaguered after minutes of staring at them. Whatever am I to do? Has anyone else suffered from this? How did you escape it? 原文链接 其实每个人都有这么一段路程——对于我们很喜欢的一件事物，突然对他失去了兴趣。怎么办？ Answer: I can understand what you felt like. It must be a very bad because you can’t do something you like. I still remember my experience when I was in Grade six. I did’t like math at all at that time because my first math teacher had to work in another school and the new teacher was an old man. I didn’t like him at all! Even though his was very funny, I couldn’t remember any words. I told it to my father. He said that it was very normal for everyone. “Never give up anything if you really like it. Nothing can stop you working on this.” I think it can help you. Maybe you don’t like some branches of math but you have to learn it, that’s okay. Nobody can just study one of them. As long as you still love math and brave enough to face any trouble, everything will work out. The best wishes to you!","categories":[],"tags":[{"name":"reddit","slug":"reddit","permalink":"http://sdltf.github.io/tags/reddit/"}]},{"title":"关于C语言指针的那些事","slug":"c-point","date":"2021-01-29T06:37:59.000Z","updated":"2021-02-22T13:02:38.865Z","comments":true,"path":"2021/01/29/c-point/","link":"","permalink":"http://sdltf.github.io/2021/01/29/c-point/","excerpt":"","text":"前提：为什么要写这篇文章指针是C语言的一大特色，也是C语言的重要组成部分。 我在学习指针的时候，发现大家对于指针的理解和说法都不一样，有些人的讲解甚至有错，导致同学们对指针的理解在根本上就产生了偏差或者错误，影响了后期的学习。 这里，我希望写一篇文章，来让初学者对指针有个基本的认识，仅此而已。 废话不多说，我们开始！ Part 1：指针的定义如果你现在对于指针的理解还是一团糟，我希望你能够忘掉你之前学的所有有关指针的东西，听听我的描述。 指针是地址，储存他的变量称为指针变量。 蒙了吗？我们从变量的储存来来一看这句话到底是什么意思。 众所周知，我们的变量，是要储存在计算机里的。 那么，我们要储存在什么地方呢？简单的理解，我们可以说他储存在内存里。 举个例子。定义int a时，编译器分配4个字节内存，并命名该4个字节的空间名字为a(即变量名)。 当用到变量名a时，就是在使用那4个字节的内存空间。 Tips:关于指针和指针变量其实我们自己都没有意识到一点：我们在谈到指针的时候，绝大多数情况都指的是指针变量而非地址。所以本文如果没有特殊说明，所有的指针都成为指针变量 所以讲道理，变量名只是一个符号，他并不能告诉我们这个变量到底储存在哪里，如果我们需要直接对这个变量进行操作，我们必须要知道这个变量背后所代替的内存到底是那一块。 这时候，大名鼎鼎的取址符&amp;就登场了。 我们可以用&amp;+变量名来获取一个变量的地址。 那么我们总得把这个地址存下来吧？ 你3+2有int a = 3+2存，3.2+2.2有double p = 3.2+2.2存，那你&amp;a自然也得找个地方存，找谁呢？找指针存。 指针的定义和一个变量的定义只有一个不同。一个指针的定义应该是类型名 *变量名例如： 12int *point;double *dou; Tips:关于指针的定义写法有的资料书上的写法是int* a，有的写法是int *a个人认为，两个写法均可。他们都代表a是一个int类型的指针但要搞清楚，如果出现下面的语句： 1int* p1, p2 这时候，p2不是int*，而是int类型 那他的赋值应该是怎样的呢？也是一样，一个指针所储存的变量地址，取决于他的类型名。int*的指针只能指向int类型的变量，doube*的指针只能指向double类型的变量。 例如： 123int *a;int b = 20;a = &amp;b; // 一定要注意！直接使用b提取出的是b的值，而使用&amp;b提取出的是变量b的地址 Part 2：指针的使用指针的使用和一个普通的变量没有多大的差别，我们这里额外的提一个运算符*，他的作用是提取抽一个指针所指向地址的值。 艾玛，好拗口，到底是什么意思呢？我们来类比一下： 假设我们有int a = 1，如果你直接使用a，意思就是使用a所储存的值，即为1；假设我们有int *p = &amp;a，如果直接使用p，意思就是使用p所储存的值，即为a的地址 Tips:我们一般把地址看做一个 代表内存地址的长的十六进制数 指针的“骚操作”来了，如果你尝试用%d输出*p，会发先：结果为1！ 这事情是怎么发生的呢？你可以这么理解： p的值即为p所指向的地址，也就是&amp;a。 而*又是提取抽一个指针所指向地址的值，相当于提取出&amp;a的值，相当于提取出a的值，也就是1。 通过*运算符，我们可以很快乐的对变量进行“远程操控”，例如： 1234567891011121314#include &lt;stdio.h&gt;void swap(int a, int b) &#123; int c; c = a; a = b; b = c;&#125;int main() &#123; int a = 5, b = 10; swap(a, b); printf(&quot;a = %d, b = %d&quot;, a, b); return 0;&#125; 这样子的交换函数看起来貌似好像大概应该也许可能没问题，但你一看输出傻了眼： a &#x3D; 5, b &#x3D; 10 为什么会这样？当你在调用swap(a, b)的时候，你干的其实和这句话没什么区别：swap(5, 10)。 为什么没区别？我们前面说过，当你调用a的时候，和调用a的值没有区别。这就导致你的swap换来换去，换的只是个值，并没有对main函数里的变量进行操控。 正确的写法应该是： 1234567891011121314#include &lt;stdio.h&gt;void swap(int *a, int *b) &#123; int c; c = *a; *a = *b; *b = c;&#125;int main() &#123; int a = 5, b = 10; swap(&amp;a, &amp;b); printf(&quot;a = %d, b = %d&quot;, a, b); return 0;&#125; 这回，我们可以在swap函数中根据传入的参数，直接操控main函数里的a和b了。 Part 3：空指针和野指针一些同学怀着激动地心写下了如下代码： 12int* p;printf(&quot;%p&quot;,p); 哦我的老天爷，你知道p指向的是什么吗？ 不知道？不知道你还敢这么写！ 当你没有让p指向某个地方的时候，你还把他用了！这个时候就会产生野指针。野指针的危害是什么？第一种是指向不可访问（操作系统不允许访问的敏感地址，譬如内核空间）的地址，结果是触发段错误，这种算是最好的情况了； 第二种是指向一个可用的、而且没什么特别意义的空间（譬如我们曾经使用过但是已经不用的栈空间或堆空间），这时候程序运行不会出错，也不会对当前程序造成损害，这种情况下会掩盖你的程序错误，让你以为程序没问题，其实是有问题的； 第三种情况就是指向了一个可用的空间，而且这个空间其实在程序中正在被使用（譬如说是程序的一个变量x），那么野指针的解引用就会刚好修改这个变量x的值，导致这个变量莫名其妙的被改变，程序出现离奇的错误。一般最终都会导致程序崩溃，或者数据被损害。这种危害是最大的。 不论如何，我们都不希望看到这些发生。于是，养成好习惯：变量先赋值。 指针你可以这么做：int *p =NULL;让指针指向空。NULL是个宏，它相当于(void *)0。void *是个比较特殊的指针类型，他可以强制转化为任意一种类型的指针。 Part 4：指针与数组&amp;字符串的梦幻联动我们用*可以对指针指向地址的值进行提取，那么这个值自然也可以运算，例如： 123int a = 5;int *p = &amp;a;(*p) ++; // a的值++ Tips:关于这个括号我个人是习惯打个括号的，当然，你也可以不打不打就一定要注意运算符的优先级问题！ 指针还可以和数组梦幻联动，例如用指针遍历整个数组： 123456int var[] = &#123;10, 100, 200&#125;;int i, *ptr;ptr = var;for ( i = 0; i &lt; MAX; i++)&#123; ptr++;&#125; 这里有两句话很核心，一是ptr = var，二是ptr ++。 问题来了：为什么ptr = var而不是ptr = &amp;var呢？ 答案：因为数组名本身就是数组首元素的地址。 Tips: 虽然数组名本身就是数组首元素的地址，但是数组和指针绝不等价！ 数组在存储的时候，每一个元素都是紧密相连的。这样我们可以只需要通过移动指针指向的位置就可以知道下一个元素的值。 那么怎么移动呢？ptr ++就是干这活的。 ++对于指针来说，可以理解为移动到下一个地址，如果把内存比作一个个小房间，你可以理解++的意思就是从房间502移动到房间503（假设是相邻的）。而数组正好就像一个长走廊，从1号房间到n号房间，他们都顺次排列，没有间隔。 同样，你也可以用--来回到上一个“房间”，用+ n来跳到后面的第n个房间。 不过请注意，如果是这样的情况： 1234int a;int *p = &amp;a;p ++; // 危printf(&quot;%d&quot;, *p); // 大危 这句话其实是很危险的。因为你也不知道p++会搞到那里去，从而诞生了野指针。 你要是能够理解数组名就是指向首元素的指针，那么你应该不难理解C风格字符串char *和char []了——他们从意义上来说可以看做等价的——你要是出去跟别人说“char*就是char[]！”被打一顿你可别找我。字符串是依靠字符数组，char[]来存储的，不代表字符数组就是字符串！ 哈？为啥？因为编译器眼中的字符串其实长这样： |下标| 0 | 1 | 2 | 3 | 4 | 5 ||–|–|–|–|–|–|–|–|–|–|| char[6] | l | u|o| g|u|&#39;\\0&#39;|看到了吗？结尾还有一个空字符\\0来表示这个字符串有结尾。而普普通通的一个字符数组是可以没有&#39;\\0&#39;的哦！ Part 5：指针与函数的梦幻联动我们上面简单的介绍了数组与指针的梦幻联动，现在我们让指针和函数在一起，看看又能有什么新花样。 Part 5.1：把指针作为函数的参数这个我们其实前面讲到过，也就是swap函数： 123456void swap(int *a, int *b) &#123; int c; c = *a; *a = *b; *b = c;&#125; 当然，我们前面说过，一个数组名就是指向首元素的指针，也就是说： 123void avg(int *a);int arr[5] = &#123;0&#125;;int *a = NULL; 我们调用avg(arr)或者avg(a)都是合法的！ Part 5.2：函数返回一个指针我们来看菜鸟教程中的这一个例子： 123456789101112131415161718int * getRandom()&#123; static int r[10]; int i; srand( (unsigned)time( NULL ) ); for ( i = 0; i &lt; 10; ++i)&#123; r[i] = rand(); printf(&quot;%d\\n&quot;, r[i] ); &#125; return r;&#125;int main ()&#123; int *p; int i; p = getRandom(); for ( i = 0; i &lt; 10; i++ ) printf(&quot;*(p + [%d]) : %d\\n&quot;, i, *(p + i) ); return 0;&#125; 在这里，getRandom()生成了一个由10个随机数组成的数组，并返回了一个int*指针作为这个数组的首元素地址，我们可以用Part 4里边讲到的方式去遍历这个数组。 问题来了，这里面最关键的一句话是：static int r[10];，再重点一点，是：static。 有时候，我们希望函数中局部变量的值在函数调用结束之后不会消失（例如这里的r数组），在下一次调用该函数时，其局部变量的值仍然存在，也就是上一次函数调用结束时的值。这时候，我们就应该将该局部变量用关键字 static 声明为“静态局部变量”。他和全局变量一样，初始值都为0。 Part 5.3：函数指针我们可以通过指针来调戏用一个变量，我们自然也可以试试函数吃不吃这套。 看下面这个经典的比大小： 123456789101112#include &lt;stdio.h&gt;//返回两个数中较大的一个int max(int a, int b)&#123; return a&gt;b ? a : b;&#125;int main()&#123; int x = 5, y = 10, maxval; int (*p)(int, int) = max; maxval = (*pmax)(x, y); printf(&quot;Max value: %d\\n&quot;, maxval); return 0;&#125; 这里，int (*p)(int, int) = max;创建了一个指向函数的指针。他所指向的类型，可以看做一个返回值为int且有两个int类型作为参数的函数。 以此类推，double (*p)(double, char)所指向的类型，可以看做一个返回值为double且有一个double、一个char类型作为参数的函数。 至于他的用法，你后面就可以完全把(*p)当做一个函数的名字来用，后面直接跟空号加参数。 Tips:这里(*p)(int, int)的括号是必要的！不然会出运算符优先级的错误！ 本文引用资料 https://www.zhihu.com/question/34266997/answer/58226555 https://www.cnblogs.com/sdltf/p/13053718.html https://www.runoob.com/cprogramming/c-pointers.html http://c.biancheng.net/view/1991.html https://www.runoob.com/cprogramming/c-pointer-arithmetic.html https://www.runoob.com/cprogramming/c-array-of-pointers.html https://www.runoob.com/cprogramming/c-passing-pointers-to-functions.html https://www.jianshu.com/p/7c2a7b59e1f0 http://c.biancheng.net/view/301.html http://c.biancheng.net/view/2023.html","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://sdltf.github.io/tags/C/"}]},{"title":"CSP2020-J 复赛题解","slug":"csp2020","date":"2020-11-28T07:00:00.000Z","updated":"2021-02-22T12:58:19.187Z","comments":true,"path":"2020/11/28/csp2020/","link":"","permalink":"http://sdltf.github.io/2020/11/28/csp2020/","excerpt":"","text":"T1：优秀的拆分首先排除所有奇数，然后考虑如果这个数大于2的k次方，那就从 [公式] 一直减下去，如果出现了0那么就成功，否则失败 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;int s[] = &#123;0,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,1048576*2,1048576*2*2,1048576*2*2*2,1048576*2*2*2*2,1048576*2*2*2*2*2&#125;;int vis[20], mx;int q;using namespace std;int main() &#123; cin &gt;&gt; q; if(q % 2) &#123; cout &lt;&lt; -1; return 0; &#125; for(int i = 0; i &lt; sizeof(s)/sizeof(int); i ++) &#123; if(q &lt; s[i]) &#123; mx = i; break; &#125; &#125; for(int i = mx; i &gt; 0 &amp;&amp; q; i --) &#123; if(q &gt;= s[i]) &#123; cout &lt;&lt; s[i] &lt;&lt; &#x27; &#x27;; q -= s[i]; &#125; &#125;&#125; T2：直播领奖这是一个动态排序问题，首先考虑到sort的时间复杂度会超限，注意到数据只有600，那么不妨桶排序，只有 O（600n） ，比 O（n²logn）更优秀 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int a[605]; int main() &#123; int n, w, t, acc; cin &gt;&gt; n &gt;&gt; w; for(int p = 1;p &lt;= n;p ++)&#123; cin &gt;&gt; t; a[t] ++; acc = max(1, p * w / 100); for(int i = 600;i &gt;= 0;i --)&#123; acc -= a[i]; if(acc &lt;= 0)&#123; cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; break; &#125; &#125; &#125;&#125; T3：表达式​这个题确实有点难，不妨考虑先用栈把表达式转换为一棵树，再来把每个叶节点的值求出来，如果这个叶节点的值会影响整个树的值，那么把原有的结果取反。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1000005;char str[N], ch[N];int n, x[N], son[N][2], m, book[N], s;stack&lt;int&gt; q;int dfs1(int u) &#123; if(u &lt;= n) return x[u]; if(ch[u] == &#x27;!&#x27;) return x[u]=!dfs1(son[u][0]); else if(ch[u]==&#x27;&amp;&#x27;) &#123; x[u] = 1; x[u] &amp;= dfs1(son[u][0]); x[u] &amp;= dfs1(son[u][1]); return x[u]; &#125; else if(ch[u]==&#x27;|&#x27;) &#123; x[u] = 0; x[u] |= dfs1(son[u][0]); x[u] |= dfs1(son[u][1]); return x[u]; &#125;&#125;void dfs2(int u) &#123; book[u] = 1; if(u &gt; n) &#123; if(ch[u]==&#x27;!&#x27;) dfs2(son[u][0]); else &#123; if(ch[u] == &#x27;&amp;&#x27;) &#123; if(x[son[u][0]]) dfs2(son[u][1]); if(x[son[u][1]]) dfs2(son[u][0]); &#125; if(ch[u] == &#x27;|&#x27;) &#123; if(!x[son[u][0]]) dfs2(son[u][1]); if(!x[son[u][1]]) dfs2(son[u][0]); &#125; &#125; &#125;&#125;int main() &#123; gets(str); scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, &amp;x[i]); int len = strlen(str); m = n; for(int i = 0; i &lt; len; i ++) &#123; if(str[i] == &#x27;x&#x27;) &#123; i ++; int t = 0; while(str[i] != &#x27; &#x27;) &#123; t = t * 10 + str[i] - &#x27;0&#x27;; i++; &#125; q.push(t); &#125; else if(str[i] == &#x27;|&#x27; || str[i] == &#x27;&amp;&#x27;) &#123; int t1 = q.top(); q.pop(); int t2 = q.top(); q.pop(); m ++; son[m][0] = t1; son[m][1] = t2; q.push(m); ch[m] = str[i]; &#125; else if(str[i] == &#x27;!&#x27;) &#123; int t = q.top(); q.pop(); m ++; son[m][0] = t; q.push(m); ch[m] = str[i]; &#125; &#125; int root = q.top(); int res = dfs1(root); dfs2(root); scanf(&quot;%d&quot;, &amp;s); for(int i = 1; i &lt;= s; i ++) &#123; int k; cin &gt;&gt; k; if(!book[k]) printf(&quot;%d\\n&quot;,res); else printf(&quot;%d\\n&quot;,res^1); &#125; return 0;&#125; T4：方格取数直接考虑蛇形走法，然后很容易的就能推出式子 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 1005;LL dp[N][N];int n, m, w[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= n;i ++)&#123; for(int j = 1;j &lt;= m;j ++)&#123; cin &gt;&gt; w[i][j]; &#125; &#125; memset(dp, -0x3f3f3f3f, sizeof(dp)); dp[1][0] = 0; for(int j = 1;j &lt;= m;j ++)&#123; LL s = -0x3f3f3f3f; for(int i = 1;i &lt;= n;i ++)&#123; s = max(dp[i][j-1], s) + w[i][j]; dp[i][j] = max(s, dp[i][j]); &#125; s = -0x3f3f3f3f; for(int i = n;i &gt;= 1;i --)&#123; s = max(dp[i][j-1], s) + w[i][j]; dp[i][j] = max(s, dp[i][j]); &#125; &#125; cout &lt;&lt; dp[n][m]; return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"如何正确掌握“凡尔赛”体","slug":"fanersai","date":"2020-11-13T12:59:43.000Z","updated":"2021-07-07T01:31:25.788Z","comments":true,"path":"2020/11/13/fanersai/","link":"","permalink":"http://sdltf.github.io/2020/11/13/fanersai/","excerpt":"","text":"Part 1：什么是凡尔赛文学我们先来看几个经典凡尔赛： 唉，我又穷了，一个月花掉了别人好几个月的工资，银行卡只剩下了几万块钱了呢唉，好烦啊，为什么我狂吃了一个月才88斤呢，配上我这1.8m的小矮个，真是丑死了呢！唉，老娘我怎么这么倒霉，一回家老公就帮我提这提那，夹菜盛饭，总是给我买爱马仕的包，讨厌死这个舔狗了呢！看，第一反应是什么？阴阳怪气的炫 阴阳怪气的炫是凡尔赛文学的根本，其重点在于假装贬低自己或他人，在云淡风轻的描述中突然来一个翻转，使人刚想嘲笑你下一秒就愣住了 好了，那么，我们怎么来写这种文字呢？ Part 2：写作方法首先，我们要确定，凡尔赛文学一般适合短小一些的文案，长了别人受不了 然后，确定一下你要表达的中心思想，并且用“虽然，但是”或者“因为，所以”改写这个中心思想 举个例子，我想说我狂吃不胖，那么我的中心就是：虽然海王吃的多，但是他就是不胖 然后，找到这句话中贬低自己的部分：海王吃的多，然后用夸张的手法着重刻画一下，比如我可以说：我一天吃了三大碗牛肉面，二十个馒头，两百个鸡蛋 一定不要害羞！凡尔赛文学就是这么不 要 脸 然后带上嫌弃的语气，例如我把上面那段话改成：唉，就是关不住自己的嘴，昨天吃了三大碗牛肉面，二十个馒头，两百个鸡蛋，真是可怕死了呢！ 请注意，这个“呢！”很关键，塑造出这种阴阳怪气的效果能加分！ 前面一部分我们处理完了，再来看看后面一部分：吃不胖 这一部分一定要用不经意的语气说出来，让人觉得你是已经习以为常了，或者对这个现状感到厌烦，比如我可以改成：唉，就是关不住自己的嘴，昨天吃了三大碗牛肉面，二十个馒头，两百个鸡蛋，真是可怕死了呢！可是人家就是胖不起来，总是88斤。 最后可以再仿佛向大家征求意见，实则傲视群雄，比如：唉，就是关不住自己的嘴，昨天吃了三大碗牛肉面，二十个馒头，两百个鸡蛋，真是可怕死了呢！可是人家就是胖不起来，总是88斤，怎么胖起来这么难啊！大家帮我想想办法呗 如果觉得渲染还是不够，再来一点点欠揍的表情和炫富的图，就可以发到朋友圈等骂了（逃 Part 3：经典案例（建议记下好好学习）真的太讨厌了，男朋友送我的红色法拉利太土了，直男就这审美吗？和闺蜜去逛街，店员居然以为我是女儿，闺蜜是我妈？太气了，现在的店员真不会看人！(一位女性拿着一沓百元人民币（至少100张）将手放在BMW的方向盘上)新做的指甲不满意，老公发了个红包，聊作安慰吧。浦东的空气，无论什么时候闻起来，都不像是住人的地方（暴击啊）过头，看见提着LV包包、踩着Gucci小短靴的顾里朝我们走过来。她随手把一杯只喝了一小半的奶茶丢进路边的垃圾桶里。 于是她从刚买的巨大PRADA拎包里拿出一个用高级环保纸包装好的烟熏枪鱼三明治，包装纸上面全都是法文。（暴击*2）北大还可以（撒贝宁）我对钱没有兴趣（马云）Part 4：通过凡尔赛文学，我们看到了什么？其实我们看到的，是当代年轻人的表现欲 我要LV！没有？好！那么假装有一个！ 我要BMW！没有？好！那么假装有一个！ 如果他们都是你一点一滴努力赚来的，我们应该鼓掌，喝彩，褒扬 但是，那些为了炫耀而炫耀，上一秒还拿着LV自拍，下一秒把LV还给售货员然后趾高气扬的说：“不买！太丑了！”的人，大多都是凡尔赛文学的忠实爱好者 得不到，也要装作很有钱的样子 我giao，自己骗自己，有意思吗 这和在贫民窟里炫耀自己有一百块钱有什么区别 那些真正有钱的人，和没钱的人，哪怕都是炫富，气质也完全不同 气质，是学不来的，更不会因为梳妆打扮，豪车名牌而上升 富有诗书气自华，哪怕是还在努力996还贷款的人，没房没车的人，也可以比名媛们更加富有气质 最后一句话：做点有用的，少来凡尔赛吧","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://sdltf.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"散文","slug":"散文","permalink":"http://sdltf.github.io/tags/%E6%95%A3%E6%96%87/"}]},{"title":"【题解】ACOJ12194|BZOJ1682|USACO2005 Mar|干草危机","slug":"acoj12194","date":"2020-09-21T08:31:00.000Z","updated":"2021-02-22T12:41:13.837Z","comments":true,"path":"2020/09/21/acoj12194/","link":"","permalink":"http://sdltf.github.io/2020/09/21/acoj12194/","excerpt":"最小生成树板子","text":"最小生成树板子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct edge&#123; int u, v, w;&#125;graph[20005];inline int read()&#123; int x = 0,f = 1;char ch = getchar(); while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123;if(ch == &#x27;-&#x27;)f = -1;ch = getchar();&#125; while(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;)&#123;x = x * 10 + ch - &#x27;0&#x27;;ch = getchar();&#125; return x * f;&#125;int n, m, tot;int fa[2005];bool cmp(edge a, edge b)&#123; return a.w &lt; b.w;&#125;int find(int x)&#123; if(x == fa[x]) return x; return fa[x] = find(fa[x]);&#125;int main()&#123; n = read();m = read(); for(int i = 1;i &lt;= n;i ++) fa[i] = i; for(int i = 1;i &lt;= m;i ++) graph[i].u = read(), graph[i].v = read(), graph[i].w = read(); sort(graph + 1, graph + m + 1, cmp); for(int i = 1;;i ++)&#123; int p = find(graph[i].u), q = find(graph[i].v); if(p != q) &#123; fa[p] = q;tot ++; if(tot == n - 1) &#123; cout &lt;&lt; graph[i].w; break; &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"神奇的莫队","slug":"modui","date":"2020-09-19T18:11:00.000Z","updated":"2021-02-22T12:42:07.586Z","comments":true,"path":"2020/09/20/modui/","link":"","permalink":"http://sdltf.github.io/2020/09/20/modui/","excerpt":"Part -1: 参考资料参考资料1万分感谢这个大佬，祝他报送清华北大！本文同步发表于知乎","text":"Part -1: 参考资料参考资料1万分感谢这个大佬，祝他报送清华北大！本文同步发表于知乎 Part 0: 一些介绍莫队由莫涛神仙首次提出，是一种区间操作算法。 即便是板子题，难度也很高（差评） 所以，在阅读后文之前，请你先深呼吸，喝杯咖啡，吃点饼干，听听自己喜欢的歌 然后，停止呼吸，放下杯子，扔开饼干，摘下耳机，接受莫涛大神思想光辉的洗礼 Part 1：莫队算法的引入先别谈莫队，我们来回顾一下，遇到区间问题一般怎么解决？ 很好，暴力线段树 也就是说，我们一直在通过维护两个序列——左序列$[l,mid]$与右序列$[mid + 1,r]$，从而来维护$[l, r]$，当然，这个操作会一直递归下去 然而，当题目这么问： 令数组$Q$大小为$n$且每个元素$Q_i &lt; n$，有$m$个询问，每次询问给定$l,r$，请找出$[l,r]$中至少重复出现$k$此的数字的个数 换句话说： 在$Q_l$到$Q_r$内找出现次数多余$k$的数字的个数 of course，你可以暴力，但你会暴零 那么我们试着用线段树，首先，你需要维护左边的序列，然后你需要维护右边的序列，然后…… 然后你会发现很难做到短时间甚至$O(1)$的时间完成对线段树单一节点的维护，因为你总是要层层递进向上叠加。 淦！这不是欺负人吗 我们先试试暴力吧，用个$count$记录一下出现次数，然后在扫一遍 暴力是万能的，答案当然正确，但是你的时间复杂度哭了——$O(n^2)$ 那么我们可以看看是否可以改进一下，用上$t(wo)p(oints)$算法： 假设有两个指针，$l$和$r$，每次询问的时候用移动$l$和$r$的方式来尝试和要求区间重合 是不是有点蒙？我举个栗子 此图中，两个Q是待求的区间 初始化$r &#x3D; 0,l &#x3D; 1$ 此时，发现$l$和要求的区间左端重合了，而$r$没有，那么我们把$r$往右边移动一位 此时，$r$发现了一个新的值$0$，总数记录一下，继续右移动 $r$又发现了一个新数值$2$，总数记录一下，继续右移动 此处$2$被记录过了，总数值不变 一直到$r$与右端点重合，得到下图： 第一个区间就算处理完了，我们来看下一个 首先，$l$不在左端点，我们把它右移 这一次，$l$所遇到的数值在区间$[l, r]$只能够存在，总数不变 下一次也是如此，一直到 你会发现，这时，区间$[l,r]$将（也就是在下一次移动后）不会有$2$存在了，那么总数就一个$-1$，而正好本题需要统计的就是区间内数值的个数，总数改变： 如此循环往复，得到最终答案，所以我们可以得出这个代码 123456789101112131415161718192021int arr[maxn], cnt[maxn] // 每个位置的数值、每个数值的计数器int l = 1, r = 0, now = 0; // 左指针、右指针、当前统计结果（总数）void add(int pos) &#123; // 添加一个数 if(!cnt[arr[pos]]) ++ now; // 在区间中新出现，总数要+1 ++ cnt[arr[pos]];&#125;void del(int pos) &#123; // 删除一个数 -- cnt[arr[pos]]; if(!cnt[arr[pos]]) -- now; // 在区间中不再出现，总数要-1&#125;void work() &#123; for(int i = 1; i &lt;= q; i ++) &#123; int ql, qr; scanf(&quot;%d%d&quot;, &amp;ql, &amp;qr); while(l &lt; ql) del(l++); // 左指针在查询区间左方，左指针向右移直到与查询区间左端点重合 while(l &gt; ql) add(--l); // 左指针在查询区间左端点右方，左指针左移 while(r &lt; qr) add(++r); // 右指针在查询区间右端点左方，右指针右移 while(r &gt; qr) del(r--); // 否则左移 printf(&quot;%d\\n&quot;, now); // 输出统计结果 &#125;&#125; 嗯，干得漂亮，但是这是莫队吗？不是 如果区间特别多，$l,r$反复横跳，结果皮断了腿，时间复杂度$O(nm)$ 那么现在的问题已经变成了：如何尽量减少$l,r$移动的次数？ Part 2：莫队的正确打开方式首先，看到尽量减少$l,r$移动的次数，我们会想到排个序 排序排什么的顺序呢？是排端点吗？显然不是，哪怕左端点有序，右端点就会杂乱无章；右端点有序，左端点就会杂乱无章…… 这里，我们运用一下分块的思想，把序列分为$\\sqrt{n}$块，把查询区间按照左端点所在块的序号排个序，如果左端点所在块相同，再按右端点排序。 这个算法需要的时间复杂度为$sort+move_{\\texttt{左指针}}$ 由于$sort$的时间复杂度为$O(n\\log n)$，$move_{\\texttt{做指针}}$的时间复杂度为$O(n\\sqrt{n})$，那么总的时间复杂度为$O(n\\sqrt{n})$ 好耶！降了一个根号！鼓掌！ 其次，我们需要考虑一下更新的策略 一般来说，我们只要找到指针移动一位以后，统计数据与当前数据的差值，找出规律（可以用数学方法或打表），然后每次移动时用这个规律更新就行 最后给出总代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define maxn 1010000#define maxb 1010int aa[maxn], cnt[maxn], belong[maxn];int n, m, size, bnum, now, ans[maxn];struct query &#123; int l, r, id;&#125; q[maxn];int cmp(query a, query b) &#123; return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r);&#125;#define isdigit(x) ((x) &gt;= &#x27;0&#x27; &amp;&amp; (x) &lt;= &#x27;9&#x27;)int read() &#123; int res = 0; char c = getchar(); while(!isdigit(c)) c = getchar(); while(isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar(); return res;&#125;void printi(int x) &#123; if(x / 10) printi(x / 10); putchar(x % 10 + &#x27;0&#x27;);&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); size = sqrt(n); bnum = ceil((double)n / size); for(int i = 1; i &lt;= bnum; ++i) for(int j = (i - 1) * size + 1; j &lt;= i * size; ++j) &#123; belong[j] = i; &#125; for(int i = 1; i &lt;= n; ++i) aa[i] = read(); m = read(); for(int i = 1; i &lt;= m; ++i) &#123; q[i].l = read(), q[i].r = read(); q[i].id = i; &#125; sort(q + 1, q + m + 1, cmp); int l = 1, r = 0; for(int i = 1; i &lt;= m; ++i) &#123; int ql = q[i].l, qr = q[i].r; while(l &lt; ql) now -= !--cnt[aa[l++]]; while(l &gt; ql) now += !cnt[aa[--l]]++; while(r &lt; qr) now += !cnt[aa[++r]]++; while(r &gt; qr) now -= !--cnt[aa[r--]]; ans[q[i].id] = now; &#125; for(int i = 1; i &lt;= m; ++i) printi(ans[i]),putchar(&#x27;\\n&#x27;); return 0;&#125; Part 3：关于莫队的一些卡常数卡常数作为OIer的家常便饭，相信大家一定不陌生了 卡常数包括： 位运算 O2 快读 …… 而莫队的神奇之处在于他的独特优化：奇偶性排序原代码： 123int cmp(query a, query b) &#123; return belong[a.l] == belong[b.l] ? a.r &lt; b.r : belong[a.l] &lt; belong[b.l];&#125; 改为 123int cmp(query a, query b) &#123; return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r);&#125; 别人说跑的很快我还不信，自己跑了一下才知道…… 真的跑的很快啊…… Part 4: 能修改的莫队我知道，你拿着上面别个大佬写的代码（再次膜拜写这个代码的大佬orz）兴冲冲的去刷题，一路上披荆斩棘，直到你看到了Luogu1903——国家集训队-数颜色，你彻底傻了眼 妈耶，他要是这么一修改我岂不是要重新sort？跑了跑了 由于莫队本身就是离线的，而你需要修改，得想个办法让他在线，具体做法是：“就是再弄一指针，在修改操作上跳来跳去，如果当前修改多了就改回来，改少了就改过去，直到次数恰当为止。”（再次感谢这个大佬，，好喜欢这个解释）","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【题解】ACOJ12411越狱","slug":"acoj12411","date":"2020-09-19T16:56:00.000Z","updated":"2021-02-22T12:51:24.864Z","comments":true,"path":"2020/09/20/acoj12411/","link":"","permalink":"http://sdltf.github.io/2020/09/20/acoj12411/","excerpt":"题目传送门 思路这是个板子题，二分图的最小点覆盖","text":"题目传送门 思路这是个板子题，二分图的最小点覆盖 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int e[500][500], n, m, match[500], ans, book[500], cow[500];int dfs(int u)&#123; for (int i = 1; i &lt;= m; i++)&#123; if (e[u][i] == 1 &amp;&amp; book[i] == 0)&#123; book[i] = 1; if (match[i] == 0 || dfs(match[i]) == 1)&#123; match[i] = u; return 1; &#125; &#125; &#125; return 0;&#125;int main()&#123; int t, x, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (int i = 1; i &lt;= p; i++)&#123; cin &gt;&gt; t &gt;&gt; x; e[t][x] = 1; &#125; for (int i = 1; i &lt;= n; i++)&#123; memset(book, 0, sizeof(book)); if (dfs(i) == 1) ans ++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【题解】ACOJ12103数字连接","slug":"acoj12103","date":"2020-09-19T16:47:00.000Z","updated":"2021-02-22T12:52:12.638Z","comments":true,"path":"2020/09/20/acoj12103/","link":"","permalink":"http://sdltf.github.io/2020/09/20/acoj12103/","excerpt":"题面传送门 解法：看到连接字符串，第一反应肯定是比较它们的字典序假设我们只比较字典序，代码如下：","text":"题面传送门 解法：看到连接字符串，第一反应肯定是比较它们的字典序假设我们只比较字典序，代码如下： 123456789101112131415161718192021#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;string&gt; s;int main()&#123; string t; int n,flag = 0; cin &gt;&gt; n; for(int i = 0;i &lt; n;i ++) &#123; cin &gt;&gt; t; s.push_back(t); &#125; sort(s.begin(), s.end()); for(int i = n - 1;i &gt;= 0;i --) &#123; // 注意，这里需要倒着输出 cout &lt;&lt; s[i]; &#125; return 0;&#125; 然而，你只能得到$20pts$。为什么？考虑这种输入： 25 50 请问最好的排法应该是什么？显然是550，而你的程序跑的是505 为什么？问题出现在了两个字符串不一样长 如何使他们一样长？下面的代码将会展示： 123456789101112131415161718192021222324252627#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;string&gt; s;bool cmp(string a,string b)&#123; if(a.length() == b.length()) return a &lt; b; else if(a.length() != b.length())&#123; string c = a+b,d = b+a; return c &lt; d; &#125;&#125;int main()&#123; string t; int n,flag = 0; cin &gt;&gt; n; for(int i = 0;i &lt; n;i ++) &#123; cin &gt;&gt; t; s.push_back(t); &#125; sort(s.begin(), s.end(),cmp); for(int i = n - 1;i &gt;= 0;i --) &#123; cout &lt;&lt; s[i]; &#125; return 0;&#125; 我们使用了cmp函数，如果两个字符串长度不相等，那么把他们的两种组合排列出来，看看哪个排列的字典序大","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【题解】LuoguP5728旗鼓相当的对手","slug":"luogu5728","date":"2020-05-16T01:04:00.000Z","updated":"2022-06-24T04:27:59.276Z","comments":true,"path":"2020/05/16/luogu5728/","link":"","permalink":"http://sdltf.github.io/2020/05/16/luogu5728/","excerpt":"","text":"12345678910111213141516171819#include&lt;bits/stdc++.h&gt;struct &#123; int a,b,c&#125;stu[1000];int main () &#123; int n,sum; std::cin &gt;&gt; n; for(int i = 0;i &lt; n;i ++)std::cin &gt;&gt; stu[i].a &gt;&gt; stu[i].b &gt;&gt;stu[i].c; for(int i = 0;i &lt; n;i ++)&#123; for(int j = 0;j &lt; i;j ++)&#123; if( (std::abs(stu[i].a - stu[j].a) &lt;= 5)&amp;&amp; (std::abs(stu[i].b - stu[j].b) &lt;= 5)&amp;&amp; (std::abs(stu[i].c - stu[j].c) &lt;= 5)&amp;&amp; (std::abs((stu[i].a+stu[i].b+stu[i].c - stu[j].a - stu[j].b - stu[j].c)) &lt;= 10)) sum ++ ; &#125; &#125; std::cout &lt;&lt; sum;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Vector，array，传统数组速度的比较","slug":"vec-arr-faster","date":"2020-05-07T02:59:00.000Z","updated":"2021-02-22T12:54:44.525Z","comments":true,"path":"2020/05/07/vec-arr-faster/","link":"","permalink":"http://sdltf.github.io/2020/05/07/vec-arr-faster/","excerpt":"-1：特别鸣谢@L_T_F_：提供Windows下的debug和release的数据@东北小蟹蟹：提供Linux下的数据","text":"-1：特别鸣谢@L_T_F_：提供Windows下的debug和release的数据@东北小蟹蟹：提供Linux下的数据 0：一些声明 作者的电脑信息： 这篇文章所用的IDE：VS2019最新版 VS2019所建立的项目：控制台项目 linux下的测试由@东北小蟹蟹 提供，感谢。 本文提到的所有数据均为5次试验 所有的平均值均检验过 本位作者并无挑拨离间的意思，只是一时兴起想做个测试 如果哪里有问题，请在下边留言~ 1：为什么要写这篇文章@L_T_F_一天跟我发了一段QQ聊天的截图，具体内容是关于vector和数组的运行速度的争论。我一时也觉得很好玩，这里还是不不放上聊天截图了。于是，这篇文章就诞生了。 2：准备工作本次分为两种方式判定速度： Debug模式 Release模式 每个模式下会有四个不同的测试方式，分别为： 循环赋值 加法运算 乘法运算 随机访问 测评之前并没有考虑到除法和%，但是好像这两个是更慢的……测评也没有考虑到位运算，因为位运算挺快的。如果你有兴趣你也可以试试。他们对应的代码分别为： 1234for(int i = 0;i &lt; n;i ++) xxx[i] = 0;for(int i = 1;i &lt; n;i ++) xxx[i] = xxx[i-1]+rand()%10;for(int i = 1;i &lt; n;i ++) xxx[i] = xxx[i-1]*rand()%10;for(int i = 0;i &lt; n;i ++) xxx[i];//真·我只是访问一下 其中，xxx为unsigned long long类型，$n &#x3D; (1e5)^2$注：数组大小只有$1e5$，这里的$n$只是循环次数。时间单位：s储存时间的数据类型：long double小数位数：四舍五入到第三位rand：并没有随机数种子 3：在Windows下3.1.2：Debug下的赋值Debug下的赋值所需时间： |项目|传统数组|vector|array||:–:|:–:|:–:|:–:|:–:||第一次|0.008|0.091|0.089||第二次|0.007|0.167|0.075||第三次|0.006|0.165|0.093||第四次|0.006|0.070|0.079||第五次|0.006|0.119|0.075||平均值|0.066|0.122|0.082||最大值|0.008|0.167|0.093||最小值|0.007|0.070|0.075| 从这里可以看出，所需时间$\\texttt{方括号数组}&lt;array&lt;vector$ 3.1.2：Release下的赋值讲道理让我吃了一惊 |项目|传统数组|vector|array||:–:|:–:|:–:|:–:|:–:||第一次|0.000|0.000|0.000||第二次|0.000|0.000|0.000||第三次|0.000|0.000|0.000||第四次|0.000|0.000|0.000||第五次|0.000|0.000|0.000||平均值|0.000|0.000|0.000||最大值|0.000|0.000|0.000||最小值|0.000|0.000|0.000|讲道理，我怀疑我电脑出了问题…… 3.2.1：Debug下的加法运算如下表： |项目|传统数组|vector|array||:–:|:–:|:–:|:–:|:–:||第一次|0.116|0.205|0.131||第二次|0.069|0.182|0.184||第三次|0.079|0.150|0.151||第四次|0.097|0.156|0.130||第五次|0.077|0.155|0.185||平均值|0.087|0.169|0.156||最大值|0.116|0.205|0.185||最小值|0.097|0.155|0.130|这个时候，传统方括号数组依然遥遥领先，vector略逊色于array 3.2.2：Release下的加法运算如下表，来吧，传说中的0ms…… |项目|传统数组|vector|array||:–:|:–:|:–:|:–:|:–:||第一次|0.000|0.004|0.005||第二次|0.000|0.005|0.007||第三次|0.000|0.005|0.006||第四次|0.000|0.007|0.005||第五次|0.000|0.006|0.005||平均值|0.000|0.005(0.0054)|0.006（0.0056）||最大值|0.000|0.007|0.007||最小值|0.000|0.004|0.005| 这里array和vector其实也不分上下，但是方括号带来的0ms的确是杠杠滴…… 3.3.1：Debug下的乘法运算差距逐渐的拉开了： |项目|传统数组|vector|array||:–:|:–:|:–:|:–:|:–:||第一次|0.067|0.923|0.719||第二次|0.700|0.788|0.847||第三次|0.673|0.791|0.781||第四次|0.829|0.812|0.821||第五次|0.510|0.703|0.785||平均值|0.676|0.803|0.790||最大值|0.829|0.923|0.847||最小值|0.067|0.703|0.719| 传统数组依然是很快的，这个时候array和vector来开差距了~ 3.3.2：Release下的乘法运算|项目|传统数组|vector|array||:–:|:–:|:–:|:–:|:–:||第一次|0.097|0.923|0.719||第二次|0.070|0.788|0.847||第三次|0.123|0.791|0.781||第四次|0.141|0.812|0.821||第五次|0.770|0.703|0.785||平均值|0.240|0.803|0.790||最大值|0.141|0.923|0.847||最小值|0.970|0.703|0.719|","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://sdltf.github.io/tags/C/"},{"name":"测评","slug":"测评","permalink":"http://sdltf.github.io/tags/%E6%B5%8B%E8%AF%84/"}]},{"title":"pip更新报错","slug":"pip-error","date":"2020-04-11T07:15:00.000Z","updated":"2021-02-22T10:59:03.382Z","comments":true,"path":"2020/04/11/pip-error/","link":"","permalink":"http://sdltf.github.io/2020/04/11/pip-error/","excerpt":"","text":"BZ最近在玩QQBOT的时候，更新PIP时，发现报错。在折腾了半天后发现了解决办法： 12python -m pip install --upgrade pip -i https://pypi.douban.com/simplepython -m pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple 两个都可以","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://sdltf.github.io/tags/Python/"},{"name":"经验","slug":"经验","permalink":"http://sdltf.github.io/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"【题解】Luogu1308 统计单词数","slug":"luogu1308","date":"2020-04-07T08:59:00.000Z","updated":"2021-02-22T11:44:19.922Z","comments":true,"path":"2020/04/07/luogu1308/","link":"","permalink":"http://sdltf.github.io/2020/04/07/luogu1308/","excerpt":"细节很多，写注释里边了。","text":"细节很多，写注释里边了。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int pos = -1;//这是第一次出现的位置int count(string s, string word)&#123; //基本思路：遇到空格就匹配 int c = 0;//计数变量 string str; for(int i = 0;i &lt; s.length();i ++)&#123; if(s[i] == &#x27; &#x27;)&#123;//匹配到空格 if(word == str)&#123; ++ c; if(c == 1) pos = i - word.length();//很重要哦，c == 1代表是第一次匹配，i - word.length()是他在字符串中第一次出现的位置 &#125; str = &quot;&quot;;//清空，或者str.clean() &#125; else str += s[i];//否则就增加 &#125; return c;&#125;int main()&#123; string s, word; cin &gt;&gt; word; s = &#x27;\\n&#x27;;//很重要！cin和getline在一起使用会导致第二个getline读取换行 getline(cin, s);//给他一个换行读掉 getline(cin, s);//正常阅读 /* 其实你也可以这么写： getline(cin, word); getline(cin, s); */ //大小写转换 transform(word.begin(),word.end(),word.begin(),::tolower); transform(s.begin(),s.end(),s.begin(),::tolower); int num = count(s,word); if(num == 0)cout &lt;&lt; -1; else cout &lt;&lt; num; if(pos != -1)cout &lt;&lt; &#x27; &#x27; &lt;&lt; pos &lt;&lt; endl;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【题解】Luogu1739 表达式括号匹配","slug":"luogu1739","date":"2020-04-07T00:54:00.000Z","updated":"2021-02-22T11:45:35.013Z","comments":true,"path":"2020/04/07/luogu1739/","link":"","permalink":"http://sdltf.github.io/2020/04/07/luogu1739/","excerpt":"提示：这是一篇良心博客。在这里，你会看到所有你可能踩到的坑。所以，作者用这个方式来掩饰自己超蒻……","text":"提示：这是一篇良心博客。在这里，你会看到所有你可能踩到的坑。所以，作者用这个方式来掩饰自己超蒻…… 踩坑路程一眼看过去，水题一个！随手写了这么一个代码： 12345678910#include &lt;bits/stdc++.h&gt;int main()&#123; char c; int flag = 0; while(c = getchar()&amp;&amp; c != &#x27;@&#x27;)&#123; if(c == &#x27;(&#x27;)flag++; else if(c == &#x27;)&#x27;) flag --; &#125; std::cout &lt;&lt; !flag?&quot;YES&quot;:&quot;NO&quot;;&#125; 结果： （艹测评机你不打脸会死啊喂） 然后，改为do-while： 1234567891011#include &lt;bits/stdc++.h&gt;int main()&#123; char c; int flag = 0; do&#123; c = getchar(); if(c == &#x27;(&#x27;)flag++; else if(c == &#x27;)&#x27;) flag --; &#125;while(c != &#x27;@&#x27;); std::cout &lt;&lt; !flag?&quot;YES&quot;:&quot;NO&quot;;&#125; 再 次 吐 血再次思考，考虑到：)(这种匹配方式，那么加个特判： 12345678910111213#include &lt;bits/stdc++.h&gt;int main()&#123; char c; int flag = 0,i = 0; do&#123; c = getchar(); if(!i &amp;&amp; c == &#x27;)&#x27;)&#123;std::cout &lt;&lt; &quot;NO&quot;;return 0;&#125; if(c == &#x27;(&#x27;)flag++; if(c == &#x27;)&#x27;) flag --; i++; &#125;while(c != &#x27;@&#x27;); std::cout &lt;&lt; !flag?&quot;YES&quot;:&quot;NO&quot;;&#125; 再 次 吐 血 无奈下载了一个数据看了下……艹！还有一个\\n！再次修改代码： 12345678910111213#include &lt;bits/stdc++.h&gt;int main()&#123; char c; int flag = 0,i = 0; do&#123; c = getchar(); if(!i &amp;&amp; c == &#x27;)&#x27;)&#123;std::cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;;return 0;&#125; if(c == &#x27;(&#x27;)flag++; if(c == &#x27;)&#x27;) flag --; i++; &#125;while(c != &#x27;@&#x27;); std::cout &lt;&lt; (!flag?&quot;YES&quot;:&quot;NO&quot;) &lt;&lt; &#x27;\\n&#x27;;&#125; 我…………再次点开一个数据： 12(a*2*3+1*2+3)+(3*2)+(1*2))1*1(@ ^ ^ 哦哦哦还有个特判！结尾’(‘的情况！再次修改： 123456789101112131415#include &lt;bits/stdc++.h&gt;int main()&#123; char c = &#x27; &#x27;,before; int flag = 0,i = 0; do&#123; before = c; c = getchar(); if(!i &amp;&amp; c == &#x27;)&#x27;)&#123;std::cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;;return 0;&#125; if(c == &#x27;(&#x27;)flag++; if(c == &#x27;)&#x27;) flag --; if(before == &#x27;(&#x27; &amp;&amp; c == &#x27;@&#x27;)&#123;std::cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;;return 0;&#125; i++; &#125;while(c != &#x27;@&#x27;); std::cout &lt;&lt; (!flag?&quot;YES&quot;:&quot;NO&quot;) &lt;&lt; &#x27;\\n&#x27;;&#125; 还有？！再次点开数据： 1(0)*(2+2)*)3+4((3+10)@ 看到这个数据，我突然发现问题就在我的思路上，考虑不到)(这个情况。但是能不能顺着我的思路继续做呢？完 全 可 以。考虑到如果出现)(的话，会出现： 123flag = 0c = ) flag-- -&gt; flag = -1 ^^ 负数！那么修改一下： 12345678910111213141516#include &lt;bits/stdc++.h&gt;int main()&#123; char c = &#x27; &#x27;,before; int flag = 0,i = 0; do&#123; before = c; c = getchar(); if(!i &amp;&amp; c == &#x27;)&#x27;)&#123;std::cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;;return 0;&#125; if(c == &#x27;(&#x27;)flag++; if(c == &#x27;)&#x27;)flag--; if(flag &lt; 0)&#123;std::cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;;return 0;&#125; if(before == &#x27;(&#x27; &amp;&amp; c == &#x27;@&#x27;)&#123;std::cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;;return 0;&#125; i++; &#125;while(c != &#x27;@&#x27;); std::cout &lt;&lt; (!flag?&quot;YES&quot;:&quot;NO&quot;) &lt;&lt; &#x27;\\n&#x27;;&#125; 坑的总结 没看到换行 (结尾的特判没注意 )(的情况flag依然等于0导致错误","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【题解】luoguP5717三角形分类","slug":"luogu5717","date":"2020-04-02T06:53:00.000Z","updated":"2021-02-22T11:48:20.515Z","comments":true,"path":"2020/04/02/luogu5717/","link":"","permalink":"http://sdltf.github.io/2020/04/02/luogu5717/","excerpt":"题目大意给定$a,b,c(0&lt; a,b,c\\leq10000)$，要求： 如果三条线段不能组成一个三角形，输出$\\texttt{Not triangle}$； 如果是直角三角形，输出$\\texttt{Right triangle}$； 如果是锐角三角形，输出$\\texttt{Acute triangle}$； 如果是钝角三角形，输出$\\texttt{Obtuse triangle}$； 如果是等腰三角形，输出$\\texttt{Isosceles triangle}$； 如果是等边三角形，输出$\\texttt{Equilateral triangle}$。 如果这个三角形符合以上多个条件，请分别输出，并用换行符隔开。","text":"题目大意给定$a,b,c(0&lt; a,b,c\\leq10000)$，要求： 如果三条线段不能组成一个三角形，输出$\\texttt{Not triangle}$； 如果是直角三角形，输出$\\texttt{Right triangle}$； 如果是锐角三角形，输出$\\texttt{Acute triangle}$； 如果是钝角三角形，输出$\\texttt{Obtuse triangle}$； 如果是等腰三角形，输出$\\texttt{Isosceles triangle}$； 如果是等边三角形，输出$\\texttt{Equilateral triangle}$。 如果这个三角形符合以上多个条件，请分别输出，并用换行符隔开。 思路首先，我们知道三角形不等式，也就是：$$a+b&gt; c,a+c&gt;b,c+b&gt;a$$那么我们有第一个代码： 1if( !( (a + b &gt; c) &amp;&amp; (a + c &gt; b) &amp;&amp; (b + c &gt; a) ))cout &lt;&lt; &quot;Not triangle&quot; &lt;&lt; endl; 如果你知道勾股定理，也就是，对于一个直角三角形，一定有两直角边平方的和等于第三条边的平方，也就是：$$a^2+b^2&#x3D;c^2$$ 那么我们有： 1if(a*a+b*b==c*c) cout &lt;&lt; &quot;Right triangle&quot; &lt;&lt; endl; 那么我们要思考，锐角三角形和钝角三角形怎么办呢？不妨我们来画个图： 我们令$a$不变，移动$b,c$，那么你会发现：钝角三角形相当于直角三角形$b$的增长，那么一定有：$a^2+b^2&gt;c^2$；锐角三角形相当于$b$的缩小，那么就有：$a^2+b^2&lt;c^2$那么我们有： 123if(a*a+b*b&lt;c*c) cout &lt;&lt; &quot;Acute triangle&quot; &lt;&lt; endl;if(a*a+b*b&gt;c*c) cout &lt;&lt; &quot;Obtuse triangle&quot; &lt;&lt; endl; 那等腰三角形和等边三角形就好判断了： 12if(a==b||a==c||b==c) cout &lt;&lt; &quot;Isosceles triangle&quot; &lt;&lt; endl;if(a==b&amp;&amp;b==c) cout &lt;&lt; &quot;Equilateral triangle&quot; &lt;&lt; endl; 那么，完整代码： 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;//万能头using namespace std;void swap(int a,int b)&#123;int t;t = a;a = b;b = t;&#125;int main()&#123; int a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a&gt;b)swap(a,b); if(a&gt;b)swap(a,c); if(b&gt;c)swap(b,c); /* 这个排序很重要！ 我们在使用勾股定理的时候，(a，b)和c的顺序是不能颠倒的 */ if( !( (a + b &gt; c) &amp;&amp; (a + c &gt; b) &amp;&amp; (b + c &gt; a) ))cout &lt;&lt; &quot;Not triangle&quot; &lt;&lt; endl; else&#123;//是三角形才有下面这些东西： if(a*a+b*b==c*c) cout &lt;&lt; &quot;Right triangle&quot; &lt;&lt; endl; if(a*a+b*b&lt;c*c) cout &lt;&lt; &quot;Acute triangle&quot; &lt;&lt; endl; if(a*a+b*b&gt;c*c) cout &lt;&lt; &quot;Obtuse triangle&quot; &lt;&lt; endl; if(a==b||a==c||b==c) cout &lt;&lt; &quot;Isosceles triangle&quot; &lt;&lt; endl; if(a==b&amp;&amp;b==c) cout &lt;&lt; &quot;Equilateral triangle&quot; &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【题解】LuoguP1059明明的随机数","slug":"luogu1059","date":"2020-04-01T01:05:00.000Z","updated":"2021-02-22T11:49:14.795Z","comments":true,"path":"2020/04/01/luogu1059/","link":"","permalink":"http://sdltf.github.io/2020/04/01/luogu1059/","excerpt":"","text":"STL的sort+unique做法unique是个去重函数，其实是把重复的元素放在数组后边。代码如下： 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int a[100];int main()&#123; int len; cin &gt;&gt; len; for(int i = 0;i &lt; len;i ++)cin &gt;&gt; a[i]; sort(a,a+len); //记住！先 排 序 len = unique(a,a+len) - a; //如果你想得到前几个去重后的元素，你就得这么写 cout &lt;&lt; len &lt;&lt; endl; for(int i = 0;i &lt; len;i ++)cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;;&#125; 压行版本： 12345678910#include &lt;bits/stdc++.h&gt;int a[100],en;int main()&#123; std::cin &gt;&gt; len; for(int i = 0;i &lt; len;i ++)std::cin &gt;&gt; a[i]; std::sort(a,a+len); //记住！先 排 序 len = std::unique(a,a+len) - a; //如果你想得到前几个去重后的元素，你就得这么写 std::cout &lt;&lt; len &lt;&lt; std::endl; for(int i = 0;i &lt; len;i ++)std::cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;;&#125; 除了考试；死也不写return0; D语言做法D语言做法就是个正常做法了，代码如下： 123456789101112131415161718192021222324252627import std.stdio;void shell_sort(int[] arr, int len) &#123;//这是我自己写的一个Shell排序 int gap, i, j; int temp; for (gap = len &gt;&gt; 1; gap &gt; 0; gap = gap &gt;&gt; 1) for (i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) arr[j + gap] = arr[j]; arr[j + gap] = temp; &#125;&#125;int[100] a = [100,100,100,345,11,12350,23];int main(string[] args)&#123; int n;int c; readf(&quot;%d&quot;,&amp;n); for (int i = 0 ; o &lt; n;i ++) readf(&quot;%d&quot;,&amp;a[i]); shell_sort(a,8); for(int i = 1;i &lt; n;i ++)&#123; c = a[i]; if(!i)write(a[i],&quot; &quot;); else if(c != a[i-1])write(a[i],&quot; &quot;); else ++i; &#125; return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"这就是堆（继续更新）","slug":"heap","date":"2020-03-22T06:03:00.000Z","updated":"2021-02-22T11:50:59.653Z","comments":true,"path":"2020/03/22/heap/","link":"","permalink":"http://sdltf.github.io/2020/03/22/heap/","excerpt":"Part 0：前置知识为了更好地阅读这篇文章，你需要自己百度： 树形结构 二叉树 完全二叉树和满二叉树 数组","text":"Part 0：前置知识为了更好地阅读这篇文章，你需要自己百度： 树形结构 二叉树 完全二叉树和满二叉树 数组 Part 1：啥是堆堆是一个完全二叉树，那首先我们来画一个完全二叉树（每个圆圈的数字是他在数组里边的下表）： 容易看出堆有一个容易看出的特性（前提是你对树结构的根与叶很敏感，不敏感就记下来）：父节点为他的两个子节点的和的二分之一向下取整，也就是：$$Father &#x3D; \\lfloor \\frac{child1 + child2}{2} \\rfloor$$ 堆也有分类，一般分为大根堆和小根堆。我希望你看了这俩图后，你能区分大根堆和小根堆（这个时候圆圈里的数字是数据）：这是大根堆，接下来的是小根堆： 这里笔者给出记忆方法：上大下小大根堆，上小下大小根堆 Part 2：堆的基本操作堆的基本操作有一下几个： 上浮（上调节点） shift_up 下沉（下调节点） shift_down 插入（插入节点） push 弹出（弹出节点）pop 取顶（得到最顶端的节点） top 堆排序（排序）heap_sort 我们用比较好理解的小根堆来讲一讲前五个操作，第六个堆排序我们单独拿一节来说。 上浮我希望你记住了小根堆的特性：上小下大。假设，这个时候我们有这么一个堆：但显然，这个不是个小根堆，我们想要把他变成小根堆，我们需要： 于是他会变成这个样子： 这个操作我们把他成为：上浮。上浮的操作本质就是swap，一直当前节点与他的父节点的大小，然后选择是否交换。 1234567891011//这里的heap数组是存放堆的数组//请注意：不是所有的堆一开始就是小根堆和大根堆//在进行几次上浮和下沉后，才能保证他是一个大根堆或者小根堆void Shift_up(int i)&#123; while(i/2 &gt;= 1)&#123; //一直比较到最顶端 if(heap[i] &lt; heap[i/2])&#123; //int的特性：int/int = floor(double/double) swap(heap[i],heap[i/2]); i /= 2; //这个时候相当于指向i的一个指针要向上走，走到他的父节点 &#125; else break;&#125; 下沉上浮固然是个好方法，但有时候不让你用上浮，你也可以用下沉。还是拿这个图举例子：我们可以看到，8要向下下沉，那他该往哪里下沉？3还是9？显然是3。为什么？因为3&lt;9！那么我们就有这个代码： 12345678910void Shift_down(int i ,int n)&#123;//n表示当前有n个节点 while(i*2 &lt;= n)&#123; int t = i * 2 ; if(t+1 &lt;= n &amp;&amp; heap[T+1] &lt; heap[T]) T++; if(heap[i] &lt; heap[T])&#123; swap(heap[ i ],heap[T] ); i = T; &#125; else break;&#125; 插入我们把一个元素插入到根的末尾，然后让他上浮就好了： 12345void Push(x)&#123; n++; //n是表示当前有多少个元素 heap[n] = x; Shift_up(n);&#125; 弹出让根节点元素和尾节点进行交换，然后让现在的根元素下沉就可以了。 12345void Pop(x)&#123; swap(heap[1],heap[n]); n--; Shift_down( 1 );&#125; 取顶这个你不会请滚回百度百科吧： 123int top()&#123; return heap[1];&#125; 堆排序堆排序真的在排序吗？不是，他的本质是不断的在上浮和下调，每次让最小的一定能跑到最上面，取顶，POP，QED。 12345678void Heap_sort(int arr[])&#123; k=0; while(size &gt; 0)&#123; k++; arr[k] = top(); pop(); &#125; &#125; 复杂度$O(N log N)$，还不错，不过空间的话…… Part 3：优先级队列优先级队列其实是队列的一个变体，在小学的时候，你也许会做过这么一种题：有$n$个小朋友排队打饭，他们所需要的时间分别为$n_i$，当前一个小朋友打饭的时候，后面的小朋友就要等。怎么排序才能让等待时间之和最短。 （以下是待更新部分） Part 4：TopK问题Part 5：左偏树Part 6：更有趣的堆Part 6.1：斐波拉契堆Part 6.2：二叉堆Part 6.3 二项堆Part 6.4：斜堆","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"教程","slug":"教程","permalink":"http://sdltf.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Hexo模板制作教程","slug":"hexo-theme-make","date":"2020-03-22T06:03:00.000Z","updated":"2022-06-24T04:24:20.157Z","comments":true,"path":"2020/03/22/hexo-theme-make/","link":"","permalink":"http://sdltf.github.io/2020/03/22/hexo-theme-make/","excerpt":"Part -1：前置知识&amp;准备工作你需要准备的东西，贴心的我已经帮你把链接附带上了： Git Node.js个人建议使用v12~v14的版本 任意的文本编辑器，这里推荐使用VSCode，sublime text 一定的HTML和CSS知识，这里推荐菜鸟教程 EJS和Stylus知识 会使用Github或者Gitee等代码托管平台，这里推荐使用Github QQ群：1161431755","text":"Part -1：前置知识&amp;准备工作你需要准备的东西，贴心的我已经帮你把链接附带上了： Git Node.js个人建议使用v12~v14的版本 任意的文本编辑器，这里推荐使用VSCode，sublime text 一定的HTML和CSS知识，这里推荐菜鸟教程 EJS和Stylus知识 会使用Github或者Gitee等代码托管平台，这里推荐使用Github QQ群：1161431755 Part 0：一些废话CSP2020初赛之后感觉自己废了，准备回归whk，顺便接触了从来没有接触过的hexo theme制作——因为别的主题不敢改，不改又觉得丑。 讲道理这个东西蛮有趣，做完了也很有成就感，难度也不大。 这篇教程希望大家都能够做出自己喜欢的主题，那么，好戏开始！ Part 1：首先，弄出一个框架网上有的教程会让你手动去mkdir+creat files，但是这对初学者极其不友好，很容易就出错了！ 因此，我们这里使用yo来直接生成一个主题。 当然，你也可以把landscape当做模板主题来使用。 这里还是给大家说一下怎么使用hexo 在任意一个地方新建一个文件夹作为你的博客文件夹，然后右键文件夹，选择Git Bash here 接着输入这里还是给大家说一下怎么使用hexo 在任意一个地方新建一个文件夹作为你的博客文件夹，然后右键文件夹，选择Git Bash here 如果有的童鞋不知道怎么用hexo，这里推荐这个dalao的教程 在你的终端中输入： 12345npm i -g yocd themesmkdir 你的主题名字chmod 675 ./ (请根据自己的情况在前面加入su / sudo）yo 接下来，如果你是使用本文的EJS+Stylus，那么应该向我这样 12345678910$ yo? &#x27;Allo SDLTF! What would you like to do? (Use arrow keys) Run a generator&gt; Hexo Theme 鈹€鈹€鈹€鈹€鈹€鈹€鈹€鈹€鈹€鈹€鈹€鈹€鈹€鈹€ Update your generators Install a generator Find some help Get me out of here!(Move up and down to reveal more choices) 这个时候直接按回车 12345Make sure you are in the directory you want to scaffold into.This generator can also be run with: yo hexo-theme--=[ generator-hexo-theme ]=--? What is the theme name? () 输入名字，按下回车。 接下来连按两次回车，然后按一个向上箭头+回车即可完成。 至此，你的目录中应该是这样的： 1234||- layout|- source|- _config.yml 恭喜！你完成了第一步 Part 2：一些基本操作这里给一个小提示： 不需要包含的东西，你可以在其文件名之前加入_，这样这个文件就不会被包含了 Part 2.1：搞清楚每个页面的功能Part 2.1.1: layout.ejs打开layout/layout.ejs，我们来解读一下这里的代码 123456789&lt;%var pageTitle = page.title || config.subtitle || &#x27;&#x27;;if (is_archive()) pageTitle = &#x27;Archives&#x27;;if (is_tag()) pageTitle = &#x27;Tag: &#x27; + page.tag;if (is_category()) pageTitle = &#x27;Category: &#x27; + page.category;if (is_month()) pageTitle += &#x27;: &#x27; + page.month + &#x27;/&#x27; + page.year;if (is_year()) pageTitle += &#x27;: &#x27; + page.year;pageTitle += &#x27; [ &#x27; + config.title + &#x27; ]&#x27;;%&gt; 由变量名可以猜到，这应该是定义了一个决定页面名称的变量。 解释一下可能出现的疑问： &lt;%是EJS脚本控制的开始，后面还会用到&lt;%-和&lt;%=等等。大部分时候，你可以把他当做JS看 is_archive()是Hexo的内置函数，用来判断这个页面是否为archive页面，其他同理 ||和C语言中的||意思大相径庭。如果a || b中a不为空，整个表达式结果为a，否则为b 继续看： 1234567891011&lt;html lang=&quot;&lt;%=config.language%&gt;&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;%=pageTitle%&gt;&lt;/title&gt; &lt;% if (theme.stylesheets !== undefined &amp;&amp; theme.stylesheets.length &gt; 0) &#123; %&gt; &lt;!-- stylesheets list from _config.yml --&gt; &lt;% theme.stylesheets.forEach(url =&gt; &#123; %&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%=url%&gt;&quot;&gt; &lt;% &#125;); %&gt; &lt;% &#125; %&gt;&lt;/head&gt; &lt;%=用于输出内容，并且是直接输出；而&lt;%-则是转为HTML后输出 config.xxx这是使用在博客根目录下的_config.yml中定义的属性，例如你在_config.yml中写了如下代码： 1I: rubbish 那么你可以使用config.I得到&quot;rubbish&quot;而theme.xxx则是使用主题目录下的_config.yml中定义的属性。 theme.stylesheets.forEach(url =&gt;这是一个循环。其中由于在主题目录下_config.yml的stylesheets是一个数组（出现了xxx:[换行] -...[换行] -...[换行] -...[换行]），则可以使用.length来获得其长度，用.foreach来进行循环，格式如下： 123xxx.forEach(i =&gt; &#123; // do something&#125; ); 等同于 123for(int i = 0;i &lt; xxx.length();i ++)&#123; // do something&#125; 后面的要着重介绍一下&lt;%- body %&gt;，这句话会让Hexo载入index.ejs，不能省略。 当然，如果你想载入其他的页面，你也可以&lt;% include &quot;Xxx&quot; %&gt; Part 2.1.2: index.ejs后面的我们会讲的比较简单。如果你看到了你看不懂的变量并且我还没有讲到，或者你想用的东西我没讲到，请阅读官方文档来找答案。 index.ejs很简单： 123456&lt;%-partial(&#x27;partials/recent-posts&#x27;)%&gt;&lt;div id=&quot;paginator&quot;&gt; &lt;%-paginator()%&gt;&lt;/div&gt; partial用来载入其他的ejs，但是partial能够传入参数，具体使用请阅读官方文档 paginator()用于插入分页，也就是页面最下方的上一页 1 2 3 4 下一页 Part 2.1.3: page.ejs依然很简单： 12345678910&lt;article id=&quot;post&quot;&gt; &lt;h1&gt;&lt;%=page.title%&gt;&lt;/h1&gt; &lt;%-page.content%&gt;&lt;/article&gt;&lt;div id=&quot;paginator&quot;&gt; &lt;%-paginator()%&gt;&lt;/div&gt; page变量是当前页面的文章，详情请看官方文档 Part 2.2： 一些常用函数的介绍在上一节中你其实可以看懂一些函数的用法，结合着官方文档，你也应该可以写出一些基本的界面。 这里将介绍一些常用函数的用法 Part 2.2.1 url_forurl_for能在路径前加上根路径 12345//_config.yml中root: /blog/&lt;%- url_for(&#x27;/a/path&#x27;) %&gt;// /blog/a/path Part 2.2.2 css&#x2F;js这两个函数用于载入文件 1234&lt;%- css(&#x27;style.css&#x27;) %&gt;// &lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;&lt;%- js(&#x27;script.js&#x27;) %&gt;// &lt;script src=&quot;/script.js&quot;&gt;&lt;/script&gt; 更多用法请参考官方文档 Part 2.2.3 strip_html这个函数可以清空字符串中的HTML标签，一般在内容摘要的显示中使用。 12&lt;%- strip_html(&#x27;It\\&#x27;s not &lt;b&gt;important&lt;/b&gt; anymore!&#x27;) %&gt;// It&#x27;s not important anymore! Part 2.2.4 date这个函数用于插入日期： 12345&lt;%- date(Date.now()) %&gt;// 2013-01-01&lt;%- date(Date.now(), &#x27;YYYY/M/D&#x27;) %&gt;// Jan 1 2013 更多用法请参考官方文档 Part 2.2.5 toc解析内容中的标题标签 (h1~h6) 并插入目录。 1&lt;%- toc(page.content) %&gt; Part 2.3： CSS和JS的用法在你的source文件夹下有两个文件夹，分别是css和js。 JS还是那个普通的JS，CSS则使用的是Stylus（你也可以用Less,Scss等） 这里只介绍几个常用的写法： Part 2.3.1 hexo-config这个函数可以使用你在主题目录的_config中定义的变量，使用方法一般为：convent(hexo-config(&#39;xxxxx&#39;)) Part 2.3.2 &amp;:这个符号用于表示上层元素，例如： 123456a &#123;&#125;a :hover&#123;&#125; 则可以写成 123a&#123; &amp;:hover&#125; Part 2.3.3 @import和C语言的include用法一样，@import &#39;xxx&#39;可以将&#39;xxx&#39;中的内容拷贝到这个文件 所以，我们一般是这样安排目录的： 12| - _particle| - xxx.styl 然后在xxx.styl中导入其他文件，因为他们已经被copy到了xxx.styl中，不需要再次被包含 Part 3：上传主题请阅读官方文档，这里我教你怎么把主题上传到github仓库 新建仓库 在git中输入： 123456git initgit add ./git commit -m &quot;first commit&quot;git branch -M mastergit remote add origin https://github.com/用户名/仓库名.gitgit push -u origin master 即可 以后的更新： 123git add ./git commit -m &quot;xxx&quot;git push","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://sdltf.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"主元素问题","slug":"main-element","date":"2020-03-22T06:03:00.000Z","updated":"2022-06-24T04:27:41.520Z","comments":true,"path":"2020/03/22/main-element/","link":"","permalink":"http://sdltf.github.io/2020/03/22/main-element/","excerpt":"Part -1：版权声明：本文大部分代码来自这篇博文","text":"Part -1：版权声明：本文大部分代码来自这篇博文 Part 0：啥是主元素问题 给一个有$n$个元素的数列，保证有一个数$a$出现的次数超过50%，求这个数 Part 1：桶计数做法桶计数做法是出现一个数，就把这个数出现次数+1，很好懂： 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int ans[10001],n,t;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;t; ans[t]++; &#125; for(int i=0;i&lt;10001;i++) if(ans[i]&gt;n/2)&#123; cout&lt;&lt;i; break; &#125;&#125; 很好懂，时间复杂度$O(N + M)$但是，一旦利用桶的思想，就不可避免的遇到一个问题：空间比如我给你的数是这样的： 1 12398517923876091 1000 1000000 10000000000 9999999 2345234618 1239 102358 12398517923876091 12398517923876091 12398517923876091 12398517923876091 12398517923876091 12398517923876091 请问你要开多大的空间？12398517923876091个数组好，有的同学说可以离散化，我再给你一组数据： 1 2 3 4 5 6 … LONG_MAX 1 1 1 …（LONG_MAX&#x2F;2个1） 从1到LONG_MAX全部给你，你怎么做？你继续离散化啊？你离散啊你离散啊你离散啊~（别问我为什么数据这么毒瘤，我自己出数据就是这么毒瘤） Part 2： 排序做法显然，若一个数列存在主元素，那么这个主元素在排序后一定位于$\\frac{n}{2}$的位置那么我们又有想法了： 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int n,a[10001];int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n);//C++ STL自带排序函数 cout&lt;&lt;a[n/2+1-1];//减1是因为这里数组从a[0]开始用 return 0;&#125; 看起来不错！$O(NlogN)$的复杂度可还行？于是，一旦有$NlogN$，就一定有人想出$N$。有吗？还真的有—— Part 3：终极做法这个数列有个特性：由于主元素的出现的次数超过50%，那么在不断的消掉两个不同的元素之后，最后一定剩下主元素有的同学会问了：如果数列长度为偶数呢？我说这位同学，请 你 审 题 给一个有$n$个元素的数列，保证有一个数$a$出现的次数超过50%，求这个数 再读一次： 保证有一个数$a$出现的次数超过50% 还不懂？再读一次： 超过50% 再不懂？滚！输入时判断与上一次保存的输入是否相同，如不同则删除两数，这里用栈来实现。 #include&lt;stdio.h&gt; int n,q[10001],top=0,a; int main() &#123; scanf(&quot;%d&quot;,&amp;n); while(n--)scanf(&quot;%d&quot;,&amp;a),q[top++]=a,top=(top&gt;1&amp;&amp;(q[top-1]!=q[top-2]))?top-2:top; printf(&quot;%d&quot;,q[top-1]); &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"因式分解","slug":"ysfj","date":"2020-03-22T06:03:00.000Z","updated":"2022-06-24T04:27:00.193Z","comments":true,"path":"2020/03/22/ysfj/","link":"","permalink":"http://sdltf.github.io/2020/03/22/ysfj/","excerpt":"Part -2：本文说明本文只介绍八年级会用到的一些因式分解技巧文章为原创，所有的公式在和Photomath中均验证过","text":"Part -2：本文说明本文只介绍八年级会用到的一些因式分解技巧文章为原创，所有的公式在和Photomath中均验证过 Part -1：幂的运算请记住以下公式：$a^b\\cdot a^c &#x3D; a^{b+c}$$\\frac{a^b}{a^c} &#x3D; a^{b-c}$$(a^m)^n &#x3D; a^{mn}$$a^c\\cdot b^c&#x3D;(ab)^c$$a^0 &#x3D; 1(a \\neq 0)$$a^{-p}&#x3D;\\frac{1}{a^p}(a\\neq 0)$ Part 0：什么是因式分解因式分解是整式乘法的逆运算，举个例子：$c(a+b) &#x3D; ac + bc$从右到左是因式分解，从左到右是整式乘法也就是说：因式分解是添加小括号，用乘法表示一个代数式整式乘法是去掉小括号，用加法表示一个代数式请注意，因式分解不改变原式的值，并且倒退回去可以得到原式 Part 1：因式分解第一招——乘法分配律！例1：对以下式子进行因式分解：$(1) 2a + 2b$$(2) 2a^2 + 4ab$$(3) 2ab + 2bc + 2abc$$(4) 2ca + 2bc^2$首先看第一个：我们可以发现，他正好符合$ac + bc$的形式，话不多说，直接运用：$\\text{解：}(1): 2a+2b &#x3D; 2(a+b)$ 再来看第二个，这个式子里边有平方，怎么办呢？请记住：目前为止，有平方？你就拆！第二个问题：4和2，怎么运用乘法分配律呢？小可爱，你知道$2\\times 2&#x3D;4$ 吗？$2a^2+4ab &#x3D; 2a\\cdot a+ 2ab \\cdot 2$提取一个$2a$，可得：$2a(a+2b)$ 第三个，有的小可爱一看到就开心了，直接提取一个$2b$：$2b(a+c+ac)$ 第四个，也很好做啊！提取$2c$：$2c(bc+a) $ Part 2：公式的运用不是所有时候都可以用到乘法分配律，于是，公式出来了：$a^2-b^2&#x3D;(a+b)(a-b)$$a^2+2ab+b^2&#x3D;(a+b)^2$$a^2-2ab+b^2&#x3D;(a-b)^2$这是你基本要记住的几个，我们来几个题：$(1)(x-y)^2-4$如果你敏感的话，你很快就能看出来：原式就是：$a^2-b^2(a &#x3D; x-y,b &#x3D; 2)$好的，直接用公式，也就是：$(x-y+2)(x-y-2)$ 第二个：$x^4-2x^2 y^2+y^4$啊哈，不就是$(a-b)^2&#x3D;a^2-2ab+b^2$嘛！直接用！转换为：$(x^2 - y^2)^2$嘿嘿嘿嘿，别忙着做下一题，你再审视一下这个式子：$(x^2 - y^2)^2$你再审视一下小括号：$x^2-y^2$此时你一惊：艹，还有一个$a^2-b^2$！继续分解，原式变为：$[(x-y)(x+y)]^2$记得前面提到的幂的运算第四条吗？反过来用，$(ab)^c&#x3D;a^cb^c$那就继续换：$(x-y)^2(x+y)^2$然而，在作者验证的时候，发现有的网站这么给答案：$(y-x)^2(y+x)^2$于是插一句话：因为偶次方具有非负性，所以：$(a-b)^2&#x3D;(b-a)^2$ Part 3：项太多了怎么办？分组！分组分解法一般用于四项及以上的分组，把他们分解之后再来运用公式或者乘法分配律。举个例子：$xy+x+y+1$四项，也不是公式，怎么办呢？分个组！分组的原则一般是：**(1)有公式可以套，(2)有相同的”系数”（使用主元法）**啊这里也没啥公式可以用，就考虑使用相同系数吧：这里我假设把y当为未知数（这是后面会讲到的主元法）$(x+1)y + (x+1)$哦，可以乘法分配律了！：$(x+1)(y+1)$ 当然，分组的灵活性很大，只能自己慢慢摸索（我指的是多刷题） Part 4：特殊二次三项式的杀手：十字相乘十字相乘用于特殊的二次三项式，特殊在哪里呢？他要满足这个要求：假设我们有一个二次三项式：$a+b+c$这个时候，令$mn&#x3D;c,pq&#x3D;a$我们要求：$qm+pn&#x3D;b$晕了吗？好吧，我要打120啦！我们上一张图： 看懂了吗？他分解之后，应该是这个样子的： 咱举个栗子：$x^2-4xy-12y^2$我们先观察，发现：$x\\cdot x &#x3D; x^2,2y \\cdot (-6y) &#x3D; -12y^2,2y\\cdot x+x \\cdot (-6y) &#x3D; -4xy$好！直接分解，变为：$(x+2y)(x-6y)$但在考试的时候，你的过程要这么写： Part End：来自DBXXX大佬的友情提示：","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://sdltf.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"循环队列","slug":"circle-que","date":"2020-03-18T04:28:00.000Z","updated":"2021-02-22T12:00:49.347Z","comments":true,"path":"2020/03/18/circle-que/","link":"","permalink":"http://sdltf.github.io/2020/03/18/circle-que/","excerpt":"Part 1：循环队列我们来看下上次我们写下的Queue： 12345678910struct Queue&#123; int que[1000]; //最大容纳1000个元素 int head = 0; //队列的第一个元素 int tail = 0; //队列的最后一个元素 void push(int x)&#123; que[tail++]=x; &#125; //增加一个 void pop()&#123; head++; &#125; //弹出第一个 bool empty()&#123; return tail-head; &#125; //是否为空 int num()&#123; return tail-head; &#125; //返回有多少个元素 int getHead()&#123; return que[head]; &#125; //获取第一个元素&#125;;","text":"Part 1：循环队列我们来看下上次我们写下的Queue： 12345678910struct Queue&#123; int que[1000]; //最大容纳1000个元素 int head = 0; //队列的第一个元素 int tail = 0; //队列的最后一个元素 void push(int x)&#123; que[tail++]=x; &#125; //增加一个 void pop()&#123; head++; &#125; //弹出第一个 bool empty()&#123; return tail-head; &#125; //是否为空 int num()&#123; return tail-head; &#125; //返回有多少个元素 int getHead()&#123; return que[head]; &#125; //获取第一个元素&#125;; 现在我们增加一个功能，获取第i个元素。 12int getNum(int x)&#123;&#125; 好的，开始在里边填充东西： 123int getNum(int x)&#123; return que[x];&#125; 但显然，如果你的x比较大的话，你会输出什么？ 那就想个办法，我们可以给他来个循环队列，也就是说，如果你的x太大了，我们就把他重新归到head，再来确定元素，就像这样： 那就开始吧！ 123int getNum(int x)&#123; return que[x%(head-tall)];&#125; 但是，如果这个队列是空的话，head-tail是0的话，会有error，我们再加一个特判： 123int getNum(int x)&#123; return !(head-tall)?-1:que[x%(head-tall)];&#125; 如果队列为空，返回一个-1。顺便咱把getHead()也重写一下： 123int getHead()&#123; return !(head-tall)?-1:que[head];&#125; 好的，循环队列就实现啦~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"教程","slug":"教程","permalink":"http://sdltf.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"啥是佩奇？哦不，啥是队列","slug":"que","date":"2020-03-18T03:06:00.000Z","updated":"2021-02-22T12:01:46.481Z","comments":true,"path":"2020/03/18/que/","link":"","permalink":"http://sdltf.github.io/2020/03/18/que/","excerpt":"Part 0：本文声明本文只介绍基本写队列方法。文章所有代码均为原创，转载请注明来源。循环队列请看这里。","text":"Part 0：本文声明本文只介绍基本写队列方法。文章所有代码均为原创，转载请注明来源。循环队列请看这里。 Part 1：啥是队列一天，一群小可爱们在排队买奶茶。 店主认识第一个小可爱，给他打了骨折（大雾），小可爱买到了奶茶，他快乐的（真的？）离开了。 其他人往前挪一位： 然后，目前排在第一位的小可爱买了奶茶，一蹦一跳的离开了： 接下来，其他人往前挪一位： 这样进行下去，最后，只剩下了一位小可爱，他买了奶茶，兴冲冲的离开了： 没有人啦！奶茶店卖完了奶茶，兴冲冲的关门了。 这就是队列，先进先出的数据结构。 Part 2：手写队列如果你已经搞清楚了队列是酱紫的，我们来尝试手写一下队列。我们简单看一下刚才排队的过程，我们可以发现，一个队列需要实现： 增加（有人来买奶茶） 弹出第一个（买完奶茶走掉） 求队列中元素个数（有多少个人） 判断队列是否为空（到底有冇得人） 获取队首元素（看看第一个小可爱到底是谁啊，咱给他打个骨折） 那么，我们尝试用数组和结构体来实现一下： 12345678910struct Queue&#123; int que[1000]; //最大容纳1000个元素 int head = 0; //队列的第一个元素 int tail = 0; //队列的最后一个元素 void push(int x)&#123;&#125; //增加一个 void pop()&#123;&#125; //弹出第一个 bool empty()&#123;&#125; //是否为空 int num()&#123;&#125; //返回有多少个元素 int getHead()&#123;&#125; //获取第一个元素&#125; 然后，我们来尝试写一下第一个函数push(int x)： 123void push(int x)&#123; que[tail++]=x;&#125; tail++是个神奇的语句，不仅可以增加一个元素，并且还可以tail指向下一个元素，增加队列的长度。第二个：push()，我们直接让head++： 123void pop()&#123; head++;&#125; 第三个：empty()，直接tail-head，因为tail一定大于等于head，想想为什么： 123bool empty()&#123; return tail-head;//tail-head为0的时候队列为空，返回0，也就是false&#125; 第四个num()其实和empty()很类似： 123int num()&#123; return tail-head;&#125; 第五个也极其简单： 123int getHead()&#123; return que[head];&#125; 完整代码： 12345678910struct Queue&#123; int que[1000]; //最大容纳1000个元素 int head = 0; //队列的第一个元素 int tail = 0; //队列的最后一个元素 void push(int x)&#123; que[tail++]=x; &#125; //增加一个 void pop()&#123; head++; &#125; //弹出第一个 bool empty()&#123; return tail-head; &#125; //是否为空 int num()&#123; return tail-head; &#125; //返回有多少个元素 int getHead()&#123; return que[head]; &#125; //获取第一个元素&#125; 我们拿去试下： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;struct Queue&#123; int que[1000]; //最大容纳1000个元素 int head = 0; //队列的第一个元素 int tail = 0; //队列的最后一个元素 void push(int x)&#123; que[tail++]=x; &#125; //增加一个 void pop()&#123; head++; &#125; //弹出第一个 bool empty()&#123; return tail-head; &#125; //是否为空 int num()&#123; return tail-head; &#125; //返回有多少个元素 int getHead()&#123; return que[head]; &#125; //获取第一个元素&#125;;int main()&#123; struct Queue queue; //买奶茶，6个人 for(int i = 0;i &lt; 6;i ++)&#123; queue.push(i); &#125; //功能测试 cout &lt;&lt; queue.getHead() &lt;&lt; endl; cout &lt;&lt; queue.num() &lt;&lt; endl; //然后弹出 for(int i = 0;i &lt; 6; i++)&#123; queue.pop();//弹出一个 cout &lt;&lt; queue.num() &lt;&lt; &#x27; &#x27;;//看看有多少元素 cout &lt;&lt; queue.getHead() &lt;&lt; endl;//获取头元素 &#125; cout &lt;&lt; queue.empty() &lt;&lt; endl;//看看是否为空&#125; 程序输出： Part 3：STL里边的queue别人也帮我们写了一个queue，我们来看看怎么用。 12345678#include&lt;queue&gt;queue&lt;int&gt; q;//队列q里边元素的的类型是intq.push(144514);q.size(); //返回1q.front(); //返回第一个元素144514q.back(); //哈，比我们多一个结尾元素q.empty(); //跟我们自己手写的empty一样q.pop(); //弹出 尝试使用STL的queue写出买奶茶程序吧~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"教程","slug":"教程","permalink":"http://sdltf.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"博客园自定义主题教程","slug":"how-to-make-cnblog-beautiful","date":"2020-03-11T06:03:00.000Z","updated":"2022-06-24T04:24:54.574Z","comments":true,"path":"2020/03/11/how-to-make-cnblog-beautiful/","link":"","permalink":"http://sdltf.github.io/2020/03/11/how-to-make-cnblog-beautiful/","excerpt":"Part -1：为什么选择博客园博客园十分好用，百度可以搜索的到，流量大，CSS也可以自己美化，香死了！","text":"Part -1：为什么选择博客园博客园十分好用，百度可以搜索的到，流量大，CSS也可以自己美化，香死了！ Part 0：认识界面在你注册一个博客园并开通博客后，在首页点击右上角的设置或者我的博客，跳转到我的博客，点击设置，跳转到这个页面：请你一定要看到博客皮肤这一块，选一个你喜欢的。在这篇教程，我选择的是SimpleMemory。选择好后，点右上角的我的博客，你就可以看到你的博客啦~接下来，请按下F12或者看下面的图，我们来认识一下你博客的一些div P.S. 不知道啥叫DIV的小可爱们，请自行百度。Div可以把他理解成一个盒子，每个页面都是分成几块几块，每一块都是一个盒子。 按下F12这个页面的布局会出现在你的眼前。为了方便，我把几个大的div给大家搬出来：最后一个就是Google Chorme按下F12的效果，很棒！ Part 1：删掉标题，自己改一个标题！按下F12，我们来看看我的L T F の Blog在哪里：如果我们要把这个删掉，请转到你的博客设置页面，在一个叫做页面定制CSS的框框里边，输入这一段CSS： 123.header&#123; display: none;&#125; P.S. 小可爱们注意啦！由于header是博客园自己定义的一个元素，在对他进行样式编辑的时候，要打上.。对他的一个属性编辑的时候，用英文冒号，并且要打上一个空格。 display能定义他的如何展示，写下这段样式后，翻到最底下提交，再去看你的博客，哈，这一块不见了！ 然后我们可以在页首定制代码定制自己的Title： 123&lt;div style=&quot;padding-top: 20px&quot;&gt;&lt;center&gt;&lt;a href=&quot;www.cnblogs.com/sdltf&quot;style=&quot;color: rgba(255,255,255);font-family: Consolas;font-size: 400%&quot;&gt;L T F の Blog&lt;/a&gt;&lt;/center&gt;&lt;/div&gt;&lt;br /&gt;&lt;div style=&quot;padding-top: 20px&quot;&gt;&lt;center&gt;&lt;a href=&quot;www.cnblogs.com/sdltf&quot;style=&quot;color: rgba(255,255,255);font-family: Consolas;font-size: 200%&quot;&gt;Less is More&lt;/a&gt;&lt;/center&gt;&lt;/div&gt; 但是背景好丑，咱给他换一个（定制CSS）： 1234#page_begin_html&#123; background-image: linear-gradient(to bottom right, #7A88FF, #7AFFAF);&#125; 顺便咱也把博客的title换一下； 12345&lt;div style=&quot;padding-top: 60px&quot;&gt;&lt;center&gt;&lt;a href=&quot;www.cnblogs.com/sdltf&quot;style=&quot;color: rgba(255,255,255) ;font-family: Consolas;font-size: 800%&quot;&gt;L T F の Blog&lt;/a&gt;&lt;/center&gt;&lt;/div&gt;&lt;br /&gt;&lt;div style=&quot;padding-top: 30px;padding-bottom: 60px&quot;&gt;&lt;center&gt;&lt;a href=&quot;www.cnblogs.com/sdltf&quot;style=&quot;color: rgba(255,255,255);font-family: Consolas;font-size: 200%&quot;&gt;Less is More&lt;/a&gt;&lt;/center&gt;&lt;/div&gt; 效果图： Part 2：修改文章内部样式我们来自定义一下，顺便把文章的Title给调整一下： 123456789101112131415161718192021#main p&#123; font-family: Consolas,&quot;微软雅黑&quot;; font-size: 16px;&#125;#main h1&#123; font-family: Consolas,&quot;微软雅黑&quot;; font-size: 260%;&#125;#main h2&#123; font-family: Consolas,&quot;微软雅黑&quot;; font-size: 200%;&#125;#main a&#123; font-family: Consolas,&quot;微软雅黑&quot;; font-size: 16px;&#125;#post_detail a&#123; font-family: Consolas,&quot;微软雅黑&quot;; font-size: 200%; text-algin: center;&#125; 好的，最好做的几个做出来了。笔者一般不用h3，你要用也可以自己定义。然后，来俩难一点的：代码块和引用（建议自己F12一下）： 1234567891011121314151617#cnblogs_post_body code,#cnblogs_post_body pre&#123; font-family: Consolas,&quot;微软雅黑&quot; !important; font-size: 14px;&#125;#cnblogs_post_body blockquote &#123; font: 14px/22px normal helvetica, sans-serif; margin-top: 10px; margin-bottom: 10px; margin-left: 50px; padding-left: 15px; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; border-left: 3px solid #ccc; background-color:#f1f1f1 &#125; 最后修理一下： 123456789101112131415161718192021222324252627282930313233343536373839404142 #header&#123; display: none;&#125;#page_begin_html&#123; background-image: linear-gradient(to bottom right, #7A88FF, #7AFFAF);&#125;#mainContent,#SideBar p&#123; font-family: Consolas,&quot;微软雅黑&quot;; font-size: 16px;&#125;#cnblogs_post_body,#SideBar a&#123; font-family: Consolas,&quot;微软雅黑&quot;; font-size: 16px;&#125;#cnblogs_post_body h1&#123; text-align:center; font-size: 230%; color: rgba(122,150,246); padding-bottom: 30px; padding-top: 30px;&#125;#postTitle2 a&#123; font-family: Consolas,&quot;微软雅黑&quot;; font-size: 200%; text-align: center;&#125;#cnblogs_post_body code,#cnblogs_post_body pre&#123; font-family: Consolas,&quot;微软雅黑&quot; !important; font-size: 14px;&#125;#cnblogs_post_body blockquote &#123; font: 14px/22px normal helvetica, sans-serif; margin-top: 10px; margin-bottom: 10px; margin-left: 50px; padding-left: 15px; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; border-left: 3px solid #ccc; background-color:#f1f1f1 &#125;效果：我的博客 Part 3：其他地方首先，去除底下的广告： 123.c_ad_block ,#under_post_news ,.c_ad_block ,#under_post_kb ,#ad_t2 &#123; display: none !important;&#125; 摘自这篇文章，把回复搞一下： 12345678910111213141516171819202122232425262728.comment_textarea &#123; background-color: #ffffff40; font-size: 15px !important; font-family: &quot;Comic Sans MS&quot;, cursive, sans-serif !important;&#125;/*回复文本框透明*/.feedbackCon img:hover &#123; -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); -ms-transform: rotateZ(360deg); -o-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;.feedbackCon img &#123; border-radius: 40px; -webkit-transition: all 0.6s ease-out; -moz-transition: all 0.5s ease-out; -ms-transition: all 0.5s ease-out; -o-transition: all 0.5s ease-out; transition: all 0.5s ease-out;&#125;/*回复区头像*/.blog_comment_body &#123; font-size: 17px; font-family: &quot;Comic Sans MS&quot;, cursive, sans-serif;&#125;.feedbackCon &#123; border-bottom: 1px solid #347ca7bf; background-color: #ffffff59;&#125; 然后把这玩意放到页首代码 123456&lt;script type=&quot;text/javascript&quot; src=&quot;https://blog-static.cnblogs.com/files/nianheng/comments.js&quot;&gt;&lt;/script&gt;&lt;!--回复区头像--&gt;&lt;script src=&quot;http://cdn.bootcss.com/bootstrap/3.2.0/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;http://files.cnblogs.com/files/ning-wang/marvin.nav.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://files.cnblogs.com/files/ning-wang/marvin.nav.js&quot;&gt;&lt;/script&gt;&lt;!--文章右侧目录--&gt; Part 4：来点JS（请先申请JS权限）这一段可以百度：博客园美化 JS，然后复制粘贴。这玩意实在太多了，经过作者测试并且觉得不错的，这里展示一下链接：来自CSDN的 来自拉勾的 来自CNBlogs的 Part 5：结束语CSS这个玩意其实很要练习一下，很多样式拼写很烦，但用着用着你就写流畅了。本人为了搞这玩意还把常见的16进制颜色及其对应的RGB背下来了，不过属实没必要。最后，祝大家玩的开心！","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://sdltf.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"【题解】LuoguP1789 插火把","slug":"luogu1789","date":"2020-03-10T09:06:00.000Z","updated":"2021-07-07T01:31:00.563Z","comments":true,"path":"2020/03/10/luogu1789/","link":"","permalink":"http://sdltf.github.io/2020/03/10/luogu1789/","excerpt":"一开始这个题目我用模拟做，这个样子：","text":"一开始这个题目我用模拟做，这个样子： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;bool light[101][101];int main()&#123; ios::sync_with_stdio(false); int n,m,k,x,y,count=0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0;i &lt; m;i ++)&#123; cin &gt;&gt; x &gt;&gt; y; light[x][y] = 1; if(x+1&lt;=n&amp;&amp;y+1&lt;=n)light[x+1][y+1] = 1; if(x-1&gt;=1&amp;&amp;y-1&gt;=1)light[x-1][y-1] = 1; if(x+1&lt;=n&amp;&amp;y-1&gt;=1)light[x+1][y-1] = 1; if(x-1&gt;=1&amp;&amp;y+1&lt;=n)light[x-1][y+1] = 1; if(x+1&lt;=n)light[x+1][y] = 1; if(x+2&lt;=n)light[x+2][y] = 1; if(x-1&gt;=1)light[x-1][y] = 1; if(x-2&gt;=1)light[x-2][y] = 1; if(y+2&lt;=n)light[x][y+2] = 1; if(y+1&lt;=n)light[x][y+1] = 1; if(y-1&gt;=1)light[x][y-1] = 1; if(y-2&gt;=1)light[x][y-2] = 1; &#125; for(int i = 0;i &lt; k;i ++)&#123; cin &gt;&gt; x &gt;&gt; y; for(int j = x;j &lt;= x+5;j ++)for(int k1 = y;k1 &lt;= 5+y;k ++)if(j&lt;=n&amp;&amp;k1&lt;=n) light[j][k1]=1; &#125; for(int j = 1;j &lt;= n;j ++)for(int k1 = 1;k1 &lt;= n;k1 ++)&#123; if(!light[j][k1]) count++; &#125; cout &lt;&lt; count; &#125; 好极了，完美输出，结果……能不能快一点？我把&amp;&amp;换成了&amp;，结果…… 没办法，那就来个记忆化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;using namespace std;bool light[101][101];int main()&#123; int n,m,k,x,y,count=0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; count = n*n ; for(int i = 0;i &lt; m;i ++)&#123; cin &gt;&gt; x &gt;&gt; y; light[x][y] = 1; if(x+1&lt;=n&amp;&amp;y+1&lt;=n)&#123; if(!light[x+1][y+1])&#123; count -- ; light[x+1][y+1] = 1; &#125; &#125; if(x-1&gt;=1&amp;&amp;y-1&gt;=1)&#123; if(!light[x-1][y-1])&#123; count --; light[x-1][y-1] = 1; &#125; &#125; if(x+1&lt;=n&amp;&amp;y-1&gt;=1)&#123; if(!light[x+1][y-1])&#123; count--; light[x+1][y-1] = 1; &#125; &#125; if(x-1&gt;=1&amp;&amp;y+1&lt;=n)&#123; if(!light[x-1][y+1])&#123; count--; light[x-1][y+1] = 1; &#125; &#125; if(x+1&lt;=n)&#123; if(!light[x+1][y])&#123; count--; light[x+1][y] = 1; &#125; &#125; if(x+2&lt;=n)&#123; if(!light[x+2][y])&#123; count--; light[x+2][y] = 1; &#125; &#125; if(x-1&gt;=1)&#123; if(!light[x-1][y])&#123; count --; light[x-1][y] = 1; &#125; &#125; if(x-2&gt;=1)&#123; if(!light[x-2][y])&#123; count --; light[x-1][y] = 1; &#125; &#125; if(y+2&lt;=n)&#123; if(!light[x][y+2])&#123; count --; light[x][y+2] = 1; &#125; &#125; if(y+1&lt;=n)&#123; if(!light[x][y+1])&#123; count --; light[x][y+1] = 1; &#125; &#125; if(y-1&gt;=1)&#123; if(!light[x][y-1])&#123; count --; light[x][y-1] = 1; &#125; &#125; if(y-2&gt;=1)&#123; if(!light[x][y-2])&#123; count --; light[x][y-1] = 1; &#125; &#125; &#125; for(int i = 0;i &lt; k;i ++)&#123; cin &gt;&gt; x &gt;&gt; y; for(int j = x;j &lt;= x+5;j ++)for(int k1 = y;k1 &lt;= 5+y;k ++)if(j&lt;=n&amp;&amp;k1&lt;=n) if(!light[j][k1])&#123; count --; light[j][k1] = 1; &#125; &#125; cout &lt;&lt; count-1; &#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"全网一定不是最好懂的C++线性筛素数","slug":"linear-prime","date":"2020-02-17T07:17:00.000Z","updated":"2021-02-22T12:37:30.183Z","comments":true,"path":"2020/02/17/linear-prime/","link":"","permalink":"http://sdltf.github.io/2020/02/17/linear-prime/","excerpt":"Part 0:概念先给几个概念（很重要）： 合数：如果$xy&#x3D;z\\text{且}x,y\\text{为正整数}$，我们就说$x,y\\text{是}z\\text{的合数}$ 素数：如果数$a$的合数只有$1,a$，则$a$就是一个素数 整除：整数$b$除以非零整数$a$，商为整数，且余数为零， 我们就说$b$能被$a$整除，记做$a | b$。数学中，求一个数的余数的运算叫做取余，用$a MOD b$表示求a除以b的余数，计算机中用%当然，如果有$a | b$，那么我们可以写成$a MOD b &#x3D; 0$ 不含0,1的所有自然数除了素数就是合数","text":"Part 0:概念先给几个概念（很重要）： 合数：如果$xy&#x3D;z\\text{且}x,y\\text{为正整数}$，我们就说$x,y\\text{是}z\\text{的合数}$ 素数：如果数$a$的合数只有$1,a$，则$a$就是一个素数 整除：整数$b$除以非零整数$a$，商为整数，且余数为零， 我们就说$b$能被$a$整除，记做$a | b$。数学中，求一个数的余数的运算叫做取余，用$a MOD b$表示求a除以b的余数，计算机中用%当然，如果有$a | b$，那么我们可以写成$a MOD b &#x3D; 0$ 不含0,1的所有自然数除了素数就是合数 Part 1:普通筛法及优化到根号首先，从普通筛法开始： 12345#include &lt;iostream&gt;using namespace std;int main()&#123; return 0;&#125; 判断一个数是不是素数，就从他的定义入手定义是啥？回顾一下： 如果数$a$的合数只有$1,a$，则$a$就是一个素数 再次回顾合数的概念： 如果$xy&#x3D;z\\text{且}x,y\\text{为正整数}$，我们就说$x,y\\text{是}z\\text{的合数}$ 我们知道，不含0的所有自然数不是素数就是合数，而我们算法的名字叫做筛素数，而素数的定义离不开合数干脆，我们把合数筛掉吧！我们从$xy&#x3D;z入手$。显然，$x,y,z \\ neq 0$，可以大胆的除一下：$x &#x3D; \\frac{z}{y}$如果你比较熟悉开头的那些定义，你就会发现：因为$x$是个正整数，所以$z | y$，也就是$z MOD y &#x3D; 0$这个地方可以好好理解一下 那么，我们开始填充代码： 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main()&#123; bool flag = 1;//素数判断标签 int n = 10;//n代表我们需要筛从1~n的素数 for(int i = 2;i &lt;= n;i ++)&#123;//很重要！公式中的z（也就是这里的i）要从2开始，想想为什么 //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl; for(int j = 2;j &lt; i;j ++)&#123;//很重要！想想为什么公式中的y（也就是这里的j）为什么从2开始，为什么要比i小？ //cout &lt;&lt; &quot;进入二层循环,j = &quot; &lt;&lt; j &lt;&lt; endl; if(i % j == 0)&#123;//如果是合数 flag = 0; //cout &lt;&lt; &quot;i % j = &quot; &lt;&lt; i%j &lt;&lt; endl; //cout &lt;&lt; &quot;二层循环if,i = &quot; &lt;&lt; i &lt;&lt; &quot;j = &quot; &lt;&lt; j &lt;&lt; endl; break; &#125; &#125; if(flag) cout &lt;&lt; i &lt;&lt; endl;//否则输出 flag = 1;//小细节~自己模拟一下 &#125;&#125; 好的，代码是出来了可以更快吗？当然可以我举个例子：36。 36的因数有：{1,36},{2,18},{3,12},{4,9},{6,6} 把36的因数排个序：{1,2,3,4,6},{6,9,12,18,36}以6为分界线，我们可以把它分为了两份，请注意：$\\sqrt{36} &#x3D; 6$哇塞！我们只需要循环到$\\sqrt{n}$我们就可以结束了（因为因数是两两对应的(如果不考虑去重（比如49的因数表暂时定为：1,7,7,49)))改进一下： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; bool flag = 1;//素数判断标签 int n = 10;//n代表我们需要筛从1~n的素数 for(int i = 2;i &lt;= sqrt(n);i ++)&#123;//很重要！公式中的z（也就是这里的i）要从2开始，想想为什么 cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl; for(int j = 2;j &lt; i;j ++)&#123;//很重要！想想为什么公式中的y（也就是这里的j）为什么从2开始，为什么要比i小？ cout &lt;&lt; &quot;进入二层循环,j = &quot; &lt;&lt; j &lt;&lt; endl; if(i % j == 0)&#123;//如果是合数 flag = 0; cout &lt;&lt; &quot;i % j = &quot; &lt;&lt; i%j &lt;&lt; endl; cout &lt;&lt; &quot;二层循环if,i = &quot; &lt;&lt; i &lt;&lt; &quot;j = &quot; &lt;&lt; j &lt;&lt; endl; break; &#125; &#125; if(flag) cout &lt;&lt; &quot;------&quot; &lt;&lt; i &lt;&lt; endl;//否则输出 flag = 1; &#125;&#125; Part 2 真正的筛——埃式筛刚才那个算法的思想再怎么说，也是个取素数但是，判断合数显然比判断素数更简单那么，为什么不把合数筛走，剩下的不就是素数了吗？好办法！接下来我们想下怎么筛其实啊，可以发现某一个不为0&#x2F;1的数 × 另一个不为0&#x2F;1的数 &#x3D; 合数那么，假设有一个数$q$，我们只需要筛掉$1q,2q,3q\\text{……一直到}iq&gt;n$时，接着q++，继续筛！上代码： 1234567891011121314#include &lt;iostream&gt;//代码来自https://www.cnblogs.com/Return-blog/p/12307038.htmlusing namespace std;bool book[1000000];//素数标记盒子int main()&#123; //求1~100以内的素数 for(int i=2;i&lt;=100;i++) if(!book[i])&#123;//因为book数组在main()外部自动填充为0，所以需要!0转换为11 for(int j=i+i;j&lt;=100;j+=i)//q,2q,3q,4q... book[j]=1;//标记上1的就是合数了！ &#125; for(int i=2;i&lt;=100;i++) if(!book[i]) cout &lt;&lt; i &lt;&lt; endl;//是0就输出~ return 0;&#125; 哦太棒了！但是！请你自己模拟一下这个过程，你会发现个奇怪的过程拖慢了速度！ 当i &#x3D; 2 &#x3D;&gt; 2i&#x3D;4,3i&#x3D;6,4i&#x3D;8…当i &#x3D; 3 &#x3D;&gt; 2i&#x3D;6,3i&#x3D;9,4i&#x3D;12…当i &#x3D; 4 &#x3D;&gt; 2i&#x3D;8… Oh No！又开始重复了！重复怎么办？再筛掉！ Part 3:线性筛12345678910111213141516171819//代码来自https://www.cnblogs.com/Return-blog/p/12307038.html#include &lt;iostream&gt;using namespace std;bool book[20005];int prime[20005],pos,i,j;int main()&#123; //求1~100以内的素数 for(i=2;i&lt;=100;i++)&#123; if(!book[i]) prime[++pos]=i; //判断是否被筛过。!0（没有）的话，就记录一下， for(j=1;j&lt;=pos;j++)&#123; if(i*prime[j] &gt; 100) break; //范围：不让他超过i，超过就break book[i*prime[j]]=1; //i乘上素数得到的书就标记下，筛过了！ if(i%prime[j]==0) break; //！！！prime数组 中的素数是递增的,当 i 能整除 prime[j]，那么 i*prime[j+1] 这个合数肯定被 prime[j] 乘以某个数筛掉 想想为什么 &#125; &#125; for(int i=1;i&lt;=pos;i++) cout &lt;&lt; prime[pos]; return 0;&#125; Oh太棒了！你终于搞到了最快的方法最后送你个福利：证明一下为什么：当 i 能整除 prime[j]，那么 i*prime[j+1] 这个合数肯定被 prime[j] 乘以某个数筛掉首先，prime数组中的素数是递增的（这个不用说）因为i中含有prime[j],prime[j]比prime[j+1]小即$i&#x3D;k\\times prime[j]$那么$i\\times prime[j+1]&#x3D;(k\\times prime[j])\\times prime[j+1]$也就是$k’\\times prime[j]$看不懂没关系，板子背下来就好了~","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://sdltf.github.io/tags/C/"}]}],"categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://sdltf.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"http://sdltf.github.io/tags/C/"},{"name":"reddit","slug":"reddit","permalink":"http://sdltf.github.io/tags/reddit/"},{"name":"C","slug":"C","permalink":"http://sdltf.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://sdltf.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://sdltf.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"散文","slug":"散文","permalink":"http://sdltf.github.io/tags/%E6%95%A3%E6%96%87/"},{"name":"测评","slug":"测评","permalink":"http://sdltf.github.io/tags/%E6%B5%8B%E8%AF%84/"},{"name":"Python","slug":"Python","permalink":"http://sdltf.github.io/tags/Python/"},{"name":"经验","slug":"经验","permalink":"http://sdltf.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"数学","slug":"数学","permalink":"http://sdltf.github.io/tags/%E6%95%B0%E5%AD%A6/"}]}